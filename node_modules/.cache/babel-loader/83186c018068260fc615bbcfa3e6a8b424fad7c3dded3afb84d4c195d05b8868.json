{"ast":null,"code":"import * as React from 'react';\nimport { omit } from '../utils/omit';\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is derived from a mix of `components` props and `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according to the slot type by the type system.\n * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable\n * anchor props. Note that this is only enforced at build time by Typescript -- there is no\n * runtime code filtering props in this function.\n *\n * @param state - State including slot definitions\n * @returns An object containing the `slots` map and `slotProps` map.\n */\n\nexport function getSlots(state) {\n  const slots = {};\n  const slotProps = {};\n  const slotNames = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    const [slot, props] = getSlot(state, slotName);\n    slots[slotName] = slot;\n    slotProps[slotName] = props;\n  }\n  return {\n    slots,\n    slotProps: slotProps\n  };\n}\nfunction getSlot(state, slotName) {\n  var _a, _b, _c;\n  if (state[slotName] === undefined) {\n    return [null, undefined];\n  }\n  const {\n    children,\n    as: asProp,\n    ...rest\n  } = state[slotName];\n  const slot = ((_a = state.components) === null || _a === void 0 ? void 0 : _a[slotName]) === undefined || typeof state.components[slotName] === 'string' ? asProp || ((_b = state.components) === null || _b === void 0 ? void 0 : _b[slotName]) || 'div' : state.components[slotName];\n  if (typeof children === 'function') {\n    const render = children;\n    return [React.Fragment, {\n      children: render(slot, rest)\n    }];\n  }\n  const shouldOmitAsProp = typeof slot === 'string' && ((_c = state[slotName]) === null || _c === void 0 ? void 0 : _c.as);\n  const slotProps = shouldOmitAsProp ? omit(state[slotName], ['as']) : state[slotName];\n  return [slot, slotProps];\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,IAAT,QAAqB,eAArB;AA6BA;;;;;;;;;;;;;;;;AAgBG;;AACH,OAAM,SAAUC,QAAV,CACJC,KADI,EACoB;EAKxB,MAAMC,KAAK,GAAG,EAAd;EACA,MAAMC,SAAS,GAAG,EAAlB;EAEA,MAAMC,SAAS,GAAgBC,MAAM,CAACC,IAAP,CAAYL,KAAK,CAACM,UAAlB,CAA/B;EACA,KAAK,MAAMC,QAAX,IAAuBJ,SAAvB,EAAkC;IAChC,MAAM,CAACK,IAAD,EAAOC,KAAP,IAAgBC,OAAO,CAACV,KAAD,EAAQO,QAAR,CAA7B;IACAN,KAAK,CAACM,QAAD,CAAL,GAAkBC,IAAlB;IACAN,SAAS,CAACK,QAAD,CAAT,GAAsBE,KAAtB;EACD;EACD,OAAO;IAAER,KAAF;IAASC,SAAS,EAAGA;EAArB,CAAP;AACD;AAED,SAASQ,OAAT,CACEV,KADF,EAEEO,QAFF,EAEa;;EAEX,IAAIP,KAAK,CAACO,QAAD,CAAL,KAAoBI,SAAxB,EAAmC;IACjC,OAAO,CAAC,IAAD,EAAOA,SAAP,CAAP;EACD;EACD,MAAM;IAAEC,QAAF;IAAYC,EAAE,EAAEC,MAAhB;IAAwB,GAAGC;EAA3B,IAAoCf,KAAK,CAACO,QAAD,CAA/C;EAEA,MAAMC,IAAI,GAAI,YAAK,CAACF,UAAN,MAAgB,IAAhB,IAAgBU,aAAhB,GAAgB,MAAhB,GAAgBA,GAAGT,QAAH,CAAhB,MAAiCI,SAAjC,IAA8C,OAAOX,KAAK,CAACM,UAAN,CAAiBC,QAAjB,CAAP,KAAsC,QAApF,GACVO,MAAM,KAAI,WAAK,CAACR,UAAN,MAAgB,IAAhB,IAAgBW,aAAhB,GAAgB,MAAhB,GAAgBA,GAAGV,QAAH,CAApB,CAAN,IAA0C,KADhC,GAEVP,KAAK,CAACM,UAAN,CAAiBC,QAAjB,CAFJ;EAIA,IAAI,OAAOK,QAAP,KAAoB,UAAxB,EAAoC;IAClC,MAAMM,MAAM,GAAGN,QAAf;IACA,OAAO,CACLf,KAAK,CAACsB,QADD,EAEJ;MACCP,QAAQ,EAAEM,MAAM,CAACV,IAAD,EAAOO,IAAP;IADjB,CAFI,CAAP;EAMD;EAED,MAAMK,gBAAgB,GAAG,OAAOZ,IAAP,KAAgB,QAAhB,KAA4B,WAAK,CAACD,QAAD,CAAL,MAAe,IAAf,IAAec,aAAf,GAAe,MAAf,GAAeA,GAAER,EAA7C,CAAzB;EACA,MAAMX,SAAS,GAAIkB,gBAAgB,GAAGtB,IAAI,CAACE,KAAK,CAACO,QAAD,CAAN,EAAmB,CAAC,IAAD,CAAnB,CAAP,GAAoCP,KAAK,CAACO,QAAD,CAA5E;EAEA,OAAO,CAACC,IAAD,EAAON,SAAP,CAAP;AACD","names":["React","omit","getSlots","state","slots","slotProps","slotNames","Object","keys","components","slotName","slot","props","getSlot","undefined","children","as","asProp","rest","_a","_b","render","Fragment","shouldOmitAsProp","_c"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-utilities\\lib\\src\\packages\\react-components\\react-utilities\\src\\compose\\getSlots.ts"],"sourcesContent":["import * as React from 'react';\n\nimport { omit } from '../utils/omit';\nimport type {\n  AsIntrinsicElement,\n  ComponentState,\n  ExtractSlotProps,\n  SlotPropsRecord,\n  SlotRenderFunction,\n  UnionToIntersection,\n} from './types';\n\nexport type Slots<S extends SlotPropsRecord> = {\n  [K in keyof S]: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // for slots with an `as` prop, the slot will be any one of the possible values of `as`\n      As\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? React.ElementType<NonNullable<P>>\n    : React.ElementType<ExtractSlotProps<S[K]>>;\n};\n\ntype ObjectSlotProps<S extends SlotPropsRecord> = {\n  [K in keyof S]-?: ExtractSlotProps<S[K]> extends AsIntrinsicElement<infer As>\n    ? // For intrinsic element types, return the intersection of all possible\n      // element's props, to be compatible with the As type returned by Slots<>\n      UnionToIntersection<JSX.IntrinsicElements[As]>\n    : ExtractSlotProps<S[K]> extends React.ComponentType<infer P>\n    ? P\n    : never;\n};\n\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is derived from a mix of `components` props and `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according to the slot type by the type system.\n * For example, if the slot is rendered `as: 'a'`, the props will be filtered for acceptable\n * anchor props. Note that this is only enforced at build time by Typescript -- there is no\n * runtime code filtering props in this function.\n *\n * @param state - State including slot definitions\n * @returns An object containing the `slots` map and `slotProps` map.\n */\nexport function getSlots<R extends SlotPropsRecord>(\n  state: ComponentState<R>,\n): {\n  slots: Slots<R>;\n  slotProps: ObjectSlotProps<R>;\n} {\n  const slots = {} as Slots<R>;\n  const slotProps = {} as R;\n\n  const slotNames: (keyof R)[] = Object.keys(state.components);\n  for (const slotName of slotNames) {\n    const [slot, props] = getSlot(state, slotName);\n    slots[slotName] = slot as Slots<R>[typeof slotName];\n    slotProps[slotName] = props;\n  }\n  return { slots, slotProps: (slotProps as unknown) as ObjectSlotProps<R> };\n}\n\nfunction getSlot<R extends SlotPropsRecord, K extends keyof R>(\n  state: ComponentState<R>,\n  slotName: K,\n): readonly [React.ElementType<R[K]> | null, R[K]] {\n  if (state[slotName] === undefined) {\n    return [null, undefined as R[K]];\n  }\n  const { children, as: asProp, ...rest } = state[slotName]!;\n\n  const slot = (state.components?.[slotName] === undefined || typeof state.components[slotName] === 'string'\n    ? asProp || state.components?.[slotName] || 'div'\n    : state.components[slotName]) as React.ElementType<R[K]>;\n\n  if (typeof children === 'function') {\n    const render = children as SlotRenderFunction<R[K]>;\n    return [\n      React.Fragment,\n      ({\n        children: render(slot, rest as Omit<R[K], 'children' | 'as'>),\n      } as unknown) as R[K],\n    ];\n  }\n\n  const shouldOmitAsProp = typeof slot === 'string' && state[slotName]?.as;\n  const slotProps = (shouldOmitAsProp ? omit(state[slotName]!, ['as']) : state[slotName]) as R[K];\n\n  return [slot, slotProps];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}