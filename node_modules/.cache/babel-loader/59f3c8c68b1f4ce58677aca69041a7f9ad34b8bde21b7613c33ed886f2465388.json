{"ast":null,"code":"import * as React from 'react';\nimport { usePositioningMouseTarget, usePositioning, resolvePositioningShorthand } from '@fluentui/react-positioning';\nimport { useControllableState, useId, useOnClickOutside, useEventCallback, useOnScrollOutside } from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { elementContains } from '@fluentui/react-portal';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MENU_ENTER_EVENT, useOnMenuMouseEnter } from '../../utils/index';\nimport { useIsSubmenu } from '../../utils/useIsSubmenu';\nimport { Tab } from '@fluentui/keyboard-keys';\n/**\n * Create the state required to render Menu.\n *\n * The returned state can be modified with hooks such as useMenuStyles,\n * before being passed to renderMenu_unstable.\n *\n * @param props - props from this instance of Menu\n */\n\nexport const useMenu_unstable = props => {\n  const isSubmenu = useIsSubmenu();\n  const {\n    hoverDelay = 500,\n    inline = false,\n    hasCheckmarks = false,\n    hasIcons = false,\n    closeOnScroll = false,\n    openOnContext = false,\n    persistOnItemClick = false,\n    openOnHover = isSubmenu,\n    defaultCheckedValues\n  } = props;\n  const triggerId = useId('menu');\n  const [contextTarget, setContextTarget] = usePositioningMouseTarget();\n  const positioningState = {\n    position: isSubmenu ? 'after' : 'below',\n    align: isSubmenu ? 'top' : 'start',\n    target: props.openOnContext ? contextTarget : undefined,\n    ...resolvePositioningShorthand(props.positioning)\n  };\n  const children = React.Children.toArray(props.children);\n  if (process.env.NODE_ENV !== 'production') {\n    if (children.length === 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Menu must contain at least one child');\n    }\n    if (children.length > 2) {\n      // eslint-disable-next-line no-console\n      console.warn('Menu must contain at most two children');\n    }\n  }\n  let menuTrigger = undefined;\n  let menuPopover = undefined;\n  if (children.length === 2) {\n    menuTrigger = children[0];\n    menuPopover = children[1];\n  } else if (children.length === 1) {\n    menuPopover = children[0];\n  }\n  const {\n    targetRef: triggerRef,\n    containerRef: menuPopoverRef\n  } = usePositioning(positioningState); // TODO Better way to narrow types ?\n\n  const [open, setOpen] = useMenuOpenState({\n    hoverDelay,\n    isSubmenu,\n    setContextTarget,\n    closeOnScroll,\n    menuPopoverRef,\n    triggerRef,\n    open: props.open,\n    defaultOpen: props.defaultOpen,\n    onOpenChange: props.onOpenChange,\n    openOnContext\n  });\n  const [checkedValues, onCheckedValueChange] = useMenuSelectableState({\n    checkedValues: props.checkedValues,\n    defaultCheckedValues,\n    onCheckedValueChange: props.onCheckedValueChange\n  });\n  return {\n    inline,\n    hoverDelay,\n    triggerId,\n    isSubmenu,\n    openOnHover,\n    contextTarget,\n    setContextTarget,\n    hasCheckmarks,\n    hasIcons,\n    closeOnScroll,\n    menuTrigger,\n    menuPopover,\n    triggerRef,\n    menuPopoverRef,\n    components: {},\n    openOnContext,\n    open,\n    setOpen,\n    checkedValues,\n    onCheckedValueChange,\n    persistOnItemClick\n  };\n};\n/**\n * Adds appropriate state values and handlers for selectable items\n * i.e checkboxes and radios\n */\n\nconst useMenuSelectableState = props => {\n  const [checkedValues, setCheckedValues] = useControllableState({\n    state: props.checkedValues,\n    defaultState: props.defaultCheckedValues,\n    initialState: {}\n  });\n  const onCheckedValueChange = useEventCallback((e, _ref) => {\n    let {\n      name,\n      checkedItems\n    } = _ref;\n    var _a;\n    (_a = props.onCheckedValueChange) === null || _a === void 0 ? void 0 : _a.call(props, e, {\n      name,\n      checkedItems\n    });\n    setCheckedValues(currentValue => ({\n      ...currentValue,\n      [name]: checkedItems\n    }));\n  });\n  return [checkedValues, onCheckedValueChange];\n};\nconst useMenuOpenState = state => {\n  const {\n    targetDocument\n  } = useFluent();\n  const parentSetOpen = useMenuContext_unstable(context => context.setOpen);\n  const onOpenChange = useEventCallback((e, data) => {\n    var _a;\n    return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data);\n  });\n  const shouldHandleCloseRef = React.useRef(false);\n  const shouldHandleTabRef = React.useRef(false);\n  const pressedShiftRef = React.useRef(false);\n  const setOpenTimeout = React.useRef(0);\n  const enteringTriggerRef = React.useRef(false);\n  const [open, setOpenState] = useControllableState({\n    state: state.open,\n    defaultState: state.defaultOpen,\n    initialState: false\n  });\n  const trySetOpen = useEventCallback((e, data) => {\n    const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;\n    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {\n      ...data\n    });\n    if (data.open && e.type === 'contextmenu') {\n      state.setContextTarget(e);\n    }\n    if (!data.open) {\n      state.setContextTarget(undefined);\n      shouldHandleCloseRef.current = true;\n    }\n    if (e.type === 'keydown') {\n      if (e.key === Tab) {\n        shouldHandleTabRef.current = true;\n        pressedShiftRef.current = e.shiftKey;\n      }\n    }\n    if (data.bubble) {\n      parentSetOpen(e, {\n        ...data\n      });\n    }\n    setOpenState(data.open);\n  });\n  const setOpen = useEventCallback((e, data) => {\n    var _a;\n    clearTimeout(setOpenTimeout.current);\n    if (!(e instanceof Event) && e.persist) {\n      // < React 17 still uses pooled synthetic events\n      e.persist();\n    }\n    if (e.type === 'mouseleave' || e.type === 'mouseenter' || e.type === 'mousemove' || e.type === MENU_ENTER_EVENT) {\n      if ((_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {\n        enteringTriggerRef.current = e.type === 'mouseenter' || e.type === 'mousemove';\n      } // FIXME leaking Node timeout type\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n\n      setOpenTimeout.current = setTimeout(() => trySetOpen(e, data), state.hoverDelay);\n    } else {\n      trySetOpen(e, data);\n    }\n  });\n  useOnClickOutside({\n    contains: elementContains,\n    disabled: !open,\n    element: targetDocument,\n    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),\n    callback: event => setOpen(event, {\n      open: false,\n      type: 'clickOutside',\n      event\n    })\n  }); // only close on scroll for context, or when closeOnScroll is specified\n\n  const closeOnScroll = state.openOnContext || state.closeOnScroll;\n  useOnScrollOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: event => setOpen(event, {\n      open: false,\n      type: 'scrollOutside',\n      event\n    }),\n    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(Boolean),\n    disabled: !open || !closeOnScroll\n  });\n  useOnMenuMouseEnter({\n    element: targetDocument,\n    callback: event => {\n      // When moving from a menu directly back to its trigger, this handler can close the menu\n      // Explicitly check a flag to see if this situation happens\n      if (!enteringTriggerRef.current) {\n        setOpen(event, {\n          open: false,\n          type: 'menuMouseEnter',\n          event\n        });\n      }\n    },\n    disabled: !open,\n    refs: [state.menuPopoverRef]\n  }); // Clear timeout on unmount\n  // Setting state after a component unmounts can cause memory leaks\n\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(setOpenTimeout.current);\n    };\n  }, []); // Manage focus for open state\n\n  const {\n    findFirstFocusable,\n    findNextFocusable,\n    findPrevFocusable\n  } = useFocusFinders();\n  const focusFirst = React.useCallback(() => {\n    const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);\n    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();\n  }, [findFirstFocusable, state.menuPopoverRef]);\n  const focusAfterMenuTrigger = React.useCallback(() => {\n    const nextFocusable = findNextFocusable(state.triggerRef.current);\n    nextFocusable === null || nextFocusable === void 0 ? void 0 : nextFocusable.focus();\n  }, [findNextFocusable, state.triggerRef]);\n  const focusBeforeMenuTrigger = React.useCallback(() => {\n    const prevFocusable = findPrevFocusable(state.triggerRef.current);\n    prevFocusable === null || prevFocusable === void 0 ? void 0 : prevFocusable.focus();\n  }, [findPrevFocusable, state.triggerRef]);\n  React.useEffect(() => {\n    var _a;\n    if (open) {\n      focusFirst();\n    } else {\n      if (shouldHandleCloseRef.current) {\n        if (shouldHandleTabRef.current && !state.isSubmenu) {\n          pressedShiftRef.current ? focusBeforeMenuTrigger() : focusAfterMenuTrigger();\n        } else {\n          (_a = state.triggerRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n      }\n    }\n    shouldHandleCloseRef.current = false;\n    shouldHandleTabRef.current = false;\n    pressedShiftRef.current = false;\n  }, [state.triggerRef, state.isSubmenu, open, focusFirst, focusAfterMenuTrigger, focusBeforeMenuTrigger]);\n  return [open, setOpen];\n};","map":{"version":3,"mappings":"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","names":["React","usePositioningMouseTarget","usePositioning","resolvePositioningShorthand","useControllableState","useId","useOnClickOutside","useEventCallback","useOnScrollOutside","useFluent_unstable","useFluent","elementContains","useFocusFinders","useMenuContext_unstable","MENU_ENTER_EVENT","useOnMenuMouseEnter","useIsSubmenu","Tab","useMenu_unstable","props","isSubmenu","hoverDelay","inline","hasCheckmarks","hasIcons","closeOnScroll","openOnContext","persistOnItemClick","openOnHover","defaultCheckedValues","triggerId","contextTarget","setContextTarget","positioningState","position","align","target","undefined","positioning","children","Children","toArray","process","env","NODE_ENV","length","console","warn","menuTrigger","menuPopover","targetRef","triggerRef","containerRef","menuPopoverRef","open","setOpen","useMenuOpenState","defaultOpen","onOpenChange","checkedValues","onCheckedValueChange","useMenuSelectableState","components","setCheckedValues","state","defaultState","initialState","e","name","checkedItems","_a","currentValue","targetDocument","parentSetOpen","context","data","shouldHandleCloseRef","useRef","shouldHandleTabRef","pressedShiftRef","setOpenTimeout","enteringTriggerRef","setOpenState","trySetOpen","event","CustomEvent","type","detail","nativeEvent","current","key","shiftKey","bubble","clearTimeout","Event","persist","contains","setTimeout","disabled","element","refs","filter","Boolean","callback","useEffect","findFirstFocusable","findNextFocusable","findPrevFocusable","focusFirst","useCallback","firstFocusable","focus","focusAfterMenuTrigger","nextFocusable","focusBeforeMenuTrigger","prevFocusable"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-menu\\lib\\components\\src\\packages\\react-components\\react-menu\\src\\components\\Menu\\useMenu.tsx"],"sourcesContent":["import * as React from 'react';\nimport { usePositioningMouseTarget, usePositioning, resolvePositioningShorthand } from '@fluentui/react-positioning';\nimport {\n  useControllableState,\n  useId,\n  useOnClickOutside,\n  useEventCallback,\n  useOnScrollOutside,\n} from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { elementContains } from '@fluentui/react-portal';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MENU_ENTER_EVENT, useOnMenuMouseEnter } from '../../utils/index';\nimport { useIsSubmenu } from '../../utils/useIsSubmenu';\nimport type { MenuOpenChangeData, MenuOpenEvent, MenuProps, MenuState } from './Menu.types';\nimport { Tab } from '@fluentui/keyboard-keys';\n\n/**\n * Create the state required to render Menu.\n *\n * The returned state can be modified with hooks such as useMenuStyles,\n * before being passed to renderMenu_unstable.\n *\n * @param props - props from this instance of Menu\n */\nexport const useMenu_unstable = (props: MenuProps): MenuState => {\n  const isSubmenu = useIsSubmenu();\n  const {\n    hoverDelay = 500,\n    inline = false,\n    hasCheckmarks = false,\n    hasIcons = false,\n    closeOnScroll = false,\n    openOnContext = false,\n    persistOnItemClick = false,\n    openOnHover = isSubmenu,\n    defaultCheckedValues,\n  } = props;\n  const triggerId = useId('menu');\n  const [contextTarget, setContextTarget] = usePositioningMouseTarget();\n\n  const positioningState = {\n    position: isSubmenu ? 'after' : 'below',\n    align: isSubmenu ? 'top' : 'start',\n    target: props.openOnContext ? contextTarget : undefined,\n    ...resolvePositioningShorthand(props.positioning),\n  } as const;\n\n  const children = React.Children.toArray(props.children) as React.ReactElement[];\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (children.length === 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Menu must contain at least one child');\n    }\n\n    if (children.length > 2) {\n      // eslint-disable-next-line no-console\n      console.warn('Menu must contain at most two children');\n    }\n  }\n\n  let menuTrigger: React.ReactElement | undefined = undefined;\n  let menuPopover: React.ReactElement | undefined = undefined;\n  if (children.length === 2) {\n    menuTrigger = children[0];\n    menuPopover = children[1];\n  } else if (children.length === 1) {\n    menuPopover = children[0];\n  }\n\n  const { targetRef: triggerRef, containerRef: menuPopoverRef } = usePositioning(positioningState);\n\n  // TODO Better way to narrow types ?\n  const [open, setOpen] = useMenuOpenState({\n    hoverDelay,\n    isSubmenu,\n    setContextTarget,\n    closeOnScroll,\n    menuPopoverRef,\n    triggerRef,\n    open: props.open,\n    defaultOpen: props.defaultOpen,\n    onOpenChange: props.onOpenChange,\n    openOnContext,\n  });\n\n  const [checkedValues, onCheckedValueChange] = useMenuSelectableState({\n    checkedValues: props.checkedValues,\n    defaultCheckedValues,\n    onCheckedValueChange: props.onCheckedValueChange,\n  });\n\n  return {\n    inline,\n    hoverDelay,\n    triggerId,\n    isSubmenu,\n    openOnHover,\n    contextTarget,\n    setContextTarget,\n    hasCheckmarks,\n    hasIcons,\n    closeOnScroll,\n    menuTrigger,\n    menuPopover,\n    triggerRef,\n    menuPopoverRef,\n    components: {},\n    openOnContext,\n    open,\n    setOpen,\n    checkedValues,\n    onCheckedValueChange,\n    persistOnItemClick,\n  };\n};\n\n/**\n * Adds appropriate state values and handlers for selectable items\n * i.e checkboxes and radios\n */\nconst useMenuSelectableState = (\n  props: Pick<MenuProps, 'checkedValues' | 'defaultCheckedValues' | 'onCheckedValueChange'>,\n) => {\n  const [checkedValues, setCheckedValues] = useControllableState({\n    state: props.checkedValues,\n    defaultState: props.defaultCheckedValues,\n    initialState: {},\n  });\n  const onCheckedValueChange: MenuState['onCheckedValueChange'] = useEventCallback((e, { name, checkedItems }) => {\n    props.onCheckedValueChange?.(e, { name, checkedItems });\n\n    setCheckedValues(currentValue => ({\n      ...currentValue,\n      [name]: checkedItems,\n    }));\n  });\n\n  return [checkedValues, onCheckedValueChange] as const;\n};\n\nconst useMenuOpenState = (\n  state: Pick<\n    MenuState,\n    | 'isSubmenu'\n    | 'menuPopoverRef'\n    | 'setContextTarget'\n    | 'triggerRef'\n    | 'openOnContext'\n    | 'closeOnScroll'\n    | 'hoverDelay'\n  > &\n    Pick<MenuProps, 'open' | 'defaultOpen' | 'onOpenChange'>,\n) => {\n  const { targetDocument } = useFluent();\n  const parentSetOpen = useMenuContext_unstable(context => context.setOpen);\n  const onOpenChange: MenuProps['onOpenChange'] = useEventCallback((e, data) => state.onOpenChange?.(e, data));\n\n  const shouldHandleCloseRef = React.useRef(false);\n  const shouldHandleTabRef = React.useRef(false);\n  const pressedShiftRef = React.useRef(false);\n  const setOpenTimeout = React.useRef(0);\n  const enteringTriggerRef = React.useRef(false);\n\n  const [open, setOpenState] = useControllableState({\n    state: state.open,\n    defaultState: state.defaultOpen,\n    initialState: false,\n  });\n\n  const trySetOpen = useEventCallback((e: MenuOpenEvent, data: MenuOpenChangeData) => {\n    const event = e instanceof CustomEvent && e.type === MENU_ENTER_EVENT ? e.detail.nativeEvent : e;\n    onOpenChange?.(event, { ...data });\n    if (data.open && e.type === 'contextmenu') {\n      state.setContextTarget(e as React.MouseEvent);\n    }\n\n    if (!data.open) {\n      state.setContextTarget(undefined);\n      shouldHandleCloseRef.current = true;\n    }\n\n    if (e.type === 'keydown') {\n      if ((e as React.KeyboardEvent<HTMLElement>).key === Tab) {\n        shouldHandleTabRef.current = true;\n        pressedShiftRef.current = (e as React.KeyboardEvent<HTMLElement>).shiftKey;\n      }\n    }\n\n    if (data.bubble) {\n      parentSetOpen(e, { ...data });\n    }\n\n    setOpenState(data.open);\n  });\n\n  const setOpen = useEventCallback((e: MenuOpenEvent, data: MenuOpenChangeData) => {\n    clearTimeout(setOpenTimeout.current);\n    if (!(e instanceof Event) && e.persist) {\n      // < React 17 still uses pooled synthetic events\n      e.persist();\n    }\n\n    if (e.type === 'mouseleave' || e.type === 'mouseenter' || e.type === 'mousemove' || e.type === MENU_ENTER_EVENT) {\n      if (state.triggerRef.current?.contains(e.target as HTMLElement)) {\n        enteringTriggerRef.current = e.type === 'mouseenter' || e.type === 'mousemove';\n      }\n\n      // FIXME leaking Node timeout type\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      setOpenTimeout.current = setTimeout(() => trySetOpen(e, data), state.hoverDelay);\n    } else {\n      trySetOpen(e, data);\n    }\n  });\n\n  useOnClickOutside({\n    contains: elementContains,\n    disabled: !open,\n    element: targetDocument,\n    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(\n      Boolean,\n    ) as React.MutableRefObject<HTMLElement>[],\n    callback: event => setOpen(event, { open: false, type: 'clickOutside', event }),\n  });\n\n  // only close on scroll for context, or when closeOnScroll is specified\n  const closeOnScroll = state.openOnContext || state.closeOnScroll;\n  useOnScrollOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: event => setOpen(event, { open: false, type: 'scrollOutside', event }),\n    refs: [state.menuPopoverRef, !state.openOnContext && state.triggerRef].filter(\n      Boolean,\n    ) as React.MutableRefObject<HTMLElement>[],\n    disabled: !open || !closeOnScroll,\n  });\n\n  useOnMenuMouseEnter({\n    element: targetDocument,\n    callback: event => {\n      // When moving from a menu directly back to its trigger, this handler can close the menu\n      // Explicitly check a flag to see if this situation happens\n      if (!enteringTriggerRef.current) {\n        setOpen(event, { open: false, type: 'menuMouseEnter', event });\n      }\n    },\n    disabled: !open,\n    refs: [state.menuPopoverRef],\n  });\n\n  // Clear timeout on unmount\n  // Setting state after a component unmounts can cause memory leaks\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(setOpenTimeout.current);\n    };\n  }, []);\n\n  // Manage focus for open state\n  const { findFirstFocusable, findNextFocusable, findPrevFocusable } = useFocusFinders();\n  const focusFirst = React.useCallback(() => {\n    const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);\n    firstFocusable?.focus();\n  }, [findFirstFocusable, state.menuPopoverRef]);\n\n  const focusAfterMenuTrigger = React.useCallback(() => {\n    const nextFocusable = findNextFocusable(state.triggerRef.current);\n    nextFocusable?.focus();\n  }, [findNextFocusable, state.triggerRef]);\n\n  const focusBeforeMenuTrigger = React.useCallback(() => {\n    const prevFocusable = findPrevFocusable(state.triggerRef.current);\n    prevFocusable?.focus();\n  }, [findPrevFocusable, state.triggerRef]);\n\n  React.useEffect(() => {\n    if (open) {\n      focusFirst();\n    } else {\n      if (shouldHandleCloseRef.current) {\n        if (shouldHandleTabRef.current && !state.isSubmenu) {\n          pressedShiftRef.current ? focusBeforeMenuTrigger() : focusAfterMenuTrigger();\n        } else {\n          state.triggerRef.current?.focus();\n        }\n      }\n    }\n\n    shouldHandleCloseRef.current = false;\n    shouldHandleTabRef.current = false;\n    pressedShiftRef.current = false;\n  }, [state.triggerRef, state.isSubmenu, open, focusFirst, focusAfterMenuTrigger, focusBeforeMenuTrigger]);\n\n  return [open, setOpen] as const;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}