{"ast":null,"code":"import * as React from 'react';\nimport { useControllableState, useEventCallback, useOnClickOutside, useOnScrollOutside } from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { usePositioning, resolvePositioningShorthand, mergeArrowOffset, usePositioningMouseTarget } from '@fluentui/react-positioning';\nimport { elementContains } from '@fluentui/react-portal';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { arrowHeights } from '../PopoverSurface/index';\nimport { popoverSurfaceBorderRadius } from './constants';\n/**\n * Create the state required to render Popover.\n *\n * The returned state can be modified with hooks such as usePopoverStyles,\n * before being passed to renderPopover_unstable.\n *\n * @param props - props from this instance of Popover\n */\n\nexport const usePopover_unstable = props => {\n  var _a;\n  const [contextTarget, setContextTarget] = usePositioningMouseTarget();\n  const initialState = {\n    size: 'medium',\n    contextTarget,\n    setContextTarget,\n    ...props\n  };\n  const children = React.Children.toArray(props.children);\n  if (process.env.NODE_ENV !== 'production') {\n    if (children.length === 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Popover must contain at least one child');\n    }\n    if (children.length > 2) {\n      // eslint-disable-next-line no-console\n      console.warn('Popover must contain at most two children');\n    }\n  }\n  let popoverTrigger = undefined;\n  let popoverSurface = undefined;\n  if (children.length === 2) {\n    popoverTrigger = children[0];\n    popoverSurface = children[1];\n  } else if (children.length === 1) {\n    popoverSurface = children[0];\n  }\n  const [open, setOpenState] = useOpenState(initialState);\n  const setOpenTimeoutRef = React.useRef(0);\n  const setOpen = useEventCallback((e, shouldOpen) => {\n    var _a;\n    clearTimeout(setOpenTimeoutRef.current);\n    if (!(e instanceof Event) && e.persist) {\n      // < React 17 still uses pooled synthetic events\n      e.persist();\n    }\n    if (e.type === 'mouseleave') {\n      // FIXME leaking Node timeout type\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      setOpenTimeoutRef.current = setTimeout(() => {\n        setOpenState(e, shouldOpen);\n      }, (_a = props.mouseLeaveDelay) !== null && _a !== void 0 ? _a : 500);\n    } else {\n      setOpenState(e, shouldOpen);\n    }\n  }); // Clear timeout on unmount\n  // Setting state after a component unmounts can cause memory leaks\n\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(setOpenTimeoutRef.current);\n    };\n  }, []);\n  const toggleOpen = React.useCallback(e => {\n    setOpen(e, !open);\n  }, [setOpen, open]);\n  const positioningRefs = usePopoverRefs(initialState);\n  const {\n    targetDocument\n  } = useFluent();\n  useOnClickOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: ev => setOpen(ev, false),\n    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],\n    disabled: !open\n  }); // only close on scroll for context, or when closeOnScroll is specified\n\n  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;\n  useOnScrollOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: ev => setOpen(ev, false),\n    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],\n    disabled: !open || !closeOnScroll\n  });\n  const {\n    findFirstFocusable\n  } = useFocusFinders();\n  React.useEffect(() => {\n    var _a;\n    if (open && positioningRefs.contentRef.current) {\n      const containerTabIndex = (_a = positioningRefs.contentRef.current.getAttribute('tabIndex')) !== null && _a !== void 0 ? _a : undefined;\n      const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;\n      firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();\n    }\n  }, [findFirstFocusable, open, positioningRefs.contentRef]);\n  return {\n    ...initialState,\n    ...positioningRefs,\n    popoverTrigger,\n    popoverSurface,\n    open,\n    setOpen,\n    toggleOpen,\n    setContextTarget,\n    contextTarget,\n    inline: (_a = props.inline) !== null && _a !== void 0 ? _a : false\n  };\n};\n/**\n * Creates and manages the Popover open state\n */\n\nfunction useOpenState(state) {\n  const onOpenChange = useEventCallback((e, data) => {\n    var _a;\n    return (_a = state.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(state, e, data);\n  });\n  const [open, setOpenState] = useControllableState({\n    state: state.open,\n    defaultState: state.defaultOpen,\n    initialState: false\n  });\n  state.open = open !== undefined ? open : state.open;\n  const setContextTarget = state.setContextTarget;\n  const setOpen = React.useCallback((e, shouldOpen) => {\n    if (shouldOpen && e.type === 'contextmenu') {\n      setContextTarget(e);\n    }\n    if (!shouldOpen) {\n      setContextTarget(undefined);\n    }\n    setOpenState(shouldOpen);\n    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e, {\n      open: shouldOpen\n    });\n  }, [setOpenState, onOpenChange, setContextTarget]);\n  return [open, setOpen];\n}\n/**\n * Creates and sets the necessary trigger, target and content refs used by Popover\n */\n\nfunction usePopoverRefs(state) {\n  const positioningOptions = {\n    position: 'above',\n    align: 'center',\n    arrowPadding: 2 * popoverSurfaceBorderRadius,\n    target: state.openOnContext ? state.contextTarget : undefined,\n    ...resolvePositioningShorthand(state.positioning)\n  }; // no reason to render arrow when covering the target\n\n  if (positioningOptions.coverTarget) {\n    state.withArrow = false;\n  }\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);\n  }\n  const {\n    targetRef: triggerRef,\n    containerRef: contentRef,\n    arrowRef\n  } = usePositioning(positioningOptions);\n  return {\n    triggerRef,\n    contentRef,\n    arrowRef\n  };\n}","map":{"version":3,"mappings":"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","names":["React","useControllableState","useEventCallback","useOnClickOutside","useOnScrollOutside","useFluent_unstable","useFluent","usePositioning","resolvePositioningShorthand","mergeArrowOffset","usePositioningMouseTarget","elementContains","useFocusFinders","arrowHeights","popoverSurfaceBorderRadius","usePopover_unstable","props","contextTarget","setContextTarget","initialState","size","children","Children","toArray","process","env","NODE_ENV","length","console","warn","popoverTrigger","undefined","popoverSurface","open","setOpenState","useOpenState","setOpenTimeoutRef","useRef","setOpen","e","shouldOpen","clearTimeout","current","Event","persist","type","setTimeout","mouseLeaveDelay","_a","useEffect","toggleOpen","useCallback","positioningRefs","usePopoverRefs","targetDocument","contains","element","callback","ev","refs","triggerRef","contentRef","disabled","closeOnScroll","openOnContext","findFirstFocusable","containerTabIndex","getAttribute","firstFocusable","isNaN","focus","inline","state","onOpenChange","data","defaultState","defaultOpen","positioningOptions","position","align","arrowPadding","target","positioning","coverTarget","withArrow","offset","targetRef","containerRef","arrowRef"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-popover\\lib\\components\\src\\packages\\react-components\\react-popover\\src\\components\\Popover\\usePopover.ts"],"sourcesContent":["import * as React from 'react';\nimport {\n  useControllableState,\n  useEventCallback,\n  useOnClickOutside,\n  useOnScrollOutside,\n} from '@fluentui/react-utilities';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport {\n  usePositioning,\n  resolvePositioningShorthand,\n  mergeArrowOffset,\n  usePositioningMouseTarget,\n} from '@fluentui/react-positioning';\nimport { elementContains } from '@fluentui/react-portal';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { arrowHeights } from '../PopoverSurface/index';\nimport type { OpenPopoverEvents, PopoverProps, PopoverState } from './Popover.types';\nimport { popoverSurfaceBorderRadius } from './constants';\n\n/**\n * Create the state required to render Popover.\n *\n * The returned state can be modified with hooks such as usePopoverStyles,\n * before being passed to renderPopover_unstable.\n *\n * @param props - props from this instance of Popover\n */\nexport const usePopover_unstable = (props: PopoverProps): PopoverState => {\n  const [contextTarget, setContextTarget] = usePositioningMouseTarget();\n  const initialState = {\n    size: 'medium',\n    contextTarget,\n    setContextTarget,\n    ...props,\n  } as const;\n\n  const children = React.Children.toArray(props.children) as React.ReactElement[];\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (children.length === 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Popover must contain at least one child');\n    }\n\n    if (children.length > 2) {\n      // eslint-disable-next-line no-console\n      console.warn('Popover must contain at most two children');\n    }\n  }\n\n  let popoverTrigger: React.ReactElement | undefined = undefined;\n  let popoverSurface: React.ReactElement | undefined = undefined;\n  if (children.length === 2) {\n    popoverTrigger = children[0];\n    popoverSurface = children[1];\n  } else if (children.length === 1) {\n    popoverSurface = children[0];\n  }\n\n  const [open, setOpenState] = useOpenState(initialState);\n\n  const setOpenTimeoutRef = React.useRef(0);\n\n  const setOpen = useEventCallback((e: OpenPopoverEvents, shouldOpen: boolean) => {\n    clearTimeout(setOpenTimeoutRef.current);\n    if (!(e instanceof Event) && e.persist) {\n      // < React 17 still uses pooled synthetic events\n      e.persist();\n    }\n\n    if (e.type === 'mouseleave') {\n      // FIXME leaking Node timeout type\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      setOpenTimeoutRef.current = setTimeout(() => {\n        setOpenState(e, shouldOpen);\n      }, props.mouseLeaveDelay ?? 500);\n    } else {\n      setOpenState(e, shouldOpen);\n    }\n  });\n\n  // Clear timeout on unmount\n  // Setting state after a component unmounts can cause memory leaks\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(setOpenTimeoutRef.current);\n    };\n  }, []);\n\n  const toggleOpen = React.useCallback<PopoverState['toggleOpen']>(\n    e => {\n      setOpen(e, !open);\n    },\n    [setOpen, open],\n  );\n\n  const positioningRefs = usePopoverRefs(initialState);\n\n  const { targetDocument } = useFluent();\n  useOnClickOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: ev => setOpen(ev, false),\n    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],\n    disabled: !open,\n  });\n\n  // only close on scroll for context, or when closeOnScroll is specified\n  const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;\n  useOnScrollOutside({\n    contains: elementContains,\n    element: targetDocument,\n    callback: ev => setOpen(ev, false),\n    refs: [positioningRefs.triggerRef, positioningRefs.contentRef],\n    disabled: !open || !closeOnScroll,\n  });\n\n  const { findFirstFocusable } = useFocusFinders();\n\n  React.useEffect(() => {\n    if (open && positioningRefs.contentRef.current) {\n      const containerTabIndex = positioningRefs.contentRef.current.getAttribute('tabIndex') ?? undefined;\n      const firstFocusable = isNaN(containerTabIndex)\n        ? findFirstFocusable(positioningRefs.contentRef.current)\n        : positioningRefs.contentRef.current;\n      firstFocusable?.focus();\n    }\n  }, [findFirstFocusable, open, positioningRefs.contentRef]);\n\n  return {\n    ...initialState,\n    ...positioningRefs,\n    popoverTrigger,\n    popoverSurface,\n    open,\n    setOpen,\n    toggleOpen,\n    setContextTarget,\n    contextTarget,\n    inline: props.inline ?? false,\n  };\n};\n\n/**\n * Creates and manages the Popover open state\n */\nfunction useOpenState(\n  state: Pick<PopoverState, 'setContextTarget' | 'onOpenChange'> & Pick<PopoverProps, 'open' | 'defaultOpen'>,\n) {\n  const onOpenChange: PopoverState['onOpenChange'] = useEventCallback((e, data) => state.onOpenChange?.(e, data));\n\n  const [open, setOpenState] = useControllableState({\n    state: state.open,\n    defaultState: state.defaultOpen,\n    initialState: false,\n  });\n  state.open = open !== undefined ? open : state.open;\n  const setContextTarget = state.setContextTarget;\n\n  const setOpen = React.useCallback(\n    (e: OpenPopoverEvents, shouldOpen: boolean) => {\n      if (shouldOpen && e.type === 'contextmenu') {\n        setContextTarget(e as React.MouseEvent);\n      }\n\n      if (!shouldOpen) {\n        setContextTarget(undefined);\n      }\n\n      setOpenState(shouldOpen);\n      onOpenChange?.(e, { open: shouldOpen });\n    },\n    [setOpenState, onOpenChange, setContextTarget],\n  );\n\n  return [open, setOpen] as const;\n}\n\n/**\n * Creates and sets the necessary trigger, target and content refs used by Popover\n */\nfunction usePopoverRefs(\n  state: Pick<PopoverState, 'size' | 'contextTarget'> &\n    Pick<PopoverProps, 'positioning' | 'openOnContext' | 'withArrow'>,\n) {\n  const positioningOptions = {\n    position: 'above' as const,\n    align: 'center' as const,\n    arrowPadding: 2 * popoverSurfaceBorderRadius,\n    target: state.openOnContext ? state.contextTarget : undefined,\n    ...resolvePositioningShorthand(state.positioning),\n  };\n\n  // no reason to render arrow when covering the target\n  if (positioningOptions.coverTarget) {\n    state.withArrow = false;\n  }\n\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);\n  }\n\n  const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);\n\n  return {\n    triggerRef,\n    contentRef,\n    arrowRef,\n  } as const;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}