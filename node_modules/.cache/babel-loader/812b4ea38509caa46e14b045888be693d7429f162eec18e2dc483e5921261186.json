{"ast":null,"code":"/*! @azure/msal-browser v2.38.0 2023-07-05 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { Constants } from '@azure/msal-common';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar MsBrowserCrypto = /** @class */function () {\n  function MsBrowserCrypto() {}\n  MsBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    return window[\"msCrypto\"].getRandomValues(dataBuffer);\n  };\n  MsBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.exportKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, Constants.EMPTY_STRING).replace(/\\n/g, Constants.EMPTY_STRING).replace(/\\t/g, Constants.EMPTY_STRING).split(\" \").join(Constants.EMPTY_STRING).replace(\"\\u0000\", Constants.EMPTY_STRING);\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserStringUtils.getSortedObjectString(keyData);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.sign = function (algorithm, key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  MsBrowserCrypto.prototype.digest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  return MsBrowserCrypto;\n}();\nexport { MsBrowserCrypto };","map":{"version":3,"mappings":"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","names":["MsBrowserCrypto","dataBuffer","window","getRandomValues","algorithm","extractable","keyUsages","Promise","resolve","reject","msGenerateKey","subtle","generateKey","addEventListener","e","target","result","error","key","msExportKey","exportKey","KEY_FORMAT_JWK","resultBuffer","resultString","BrowserStringUtils","utf8ArrToString","Uint8Array","replace","Constants","EMPTY_STRING","split","join","JSON","parse","keyData","keyString","getSortedObjectString","keyBuffer","stringToArrayBuffer","msImportKey","importKey","data","msSign","sign","digestOperation","digest","buffer"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@azure\\msal-browser\\src\\crypto\\MsBrowserCrypto.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants } from \"@azure/msal-common\";\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\r\nimport { ISubtleCrypto } from \"./ISubtleCrypto\";\r\n\r\nexport class MsBrowserCrypto implements ISubtleCrypto {\r\n    getRandomValues(dataBuffer: Uint8Array): Uint8Array {\r\n        return window[\"msCrypto\"].getRandomValues(dataBuffer);\r\n    }\r\n\r\n    async generateKey(algorithm: RsaHashedKeyGenParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKeyPair> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(algorithm, extractable, keyUsages);\r\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async exportKey(key: CryptoKey): Promise<JsonWebKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\r\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\r\n                const resultBuffer: ArrayBuffer = e.target.result;\r\n\r\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\r\n                    .replace(/\\r/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\n/g, Constants.EMPTY_STRING)\r\n                    .replace(/\\t/g, Constants.EMPTY_STRING)\r\n                    .split(\" \").join(Constants.EMPTY_STRING)\r\n                    .replace(\"\\u0000\", Constants.EMPTY_STRING);\r\n\r\n                try {\r\n                    resolve(JSON.parse(resultString));\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n\r\n            msExportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async importKey(keyData: JsonWebKey, algorithm: RsaHashedImportParams, extractable: boolean, keyUsages: KeyUsage[]): Promise<CryptoKey> {\r\n        const keyString = BrowserStringUtils.getSortedObjectString(keyData);\r\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\r\n\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);\r\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msImportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    async sign(algorithm: AlgorithmIdentifier, key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msSign = window[\"msCrypto\"].subtle.sign(algorithm, key, data);\r\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msSign.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n    \r\n    async digest(algorithm: AlgorithmIdentifier, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\r\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n            digestOperation.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}