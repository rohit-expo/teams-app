{"ast":null,"code":"/**\n * Returns the parent node or the host of the node argument.\n * @param node - DOM node.\n * @returns - parent DOM node.\n */\nexport const getParentNode = node => {\n  if (node.nodeName === 'HTML') {\n    return node;\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  return node.parentNode || node.host;\n};\n/**\n * Returns CSS styles of the given node.\n * @param node - DOM node.\n * @returns - CSS styles.\n */\n\nconst getStyleComputedProperty = node => {\n  var _a;\n  if (node.nodeType !== 1) {\n    return {};\n  }\n  const window = (_a = node.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n  return window.getComputedStyle(node, null);\n};\n/**\n * Returns the first scrollable parent of the given element.\n * @param node - DOM node.\n * @returns - the first scrollable parent.\n */\n\nexport const getScrollParent = node => {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  const parentNode = node && getParentNode(node); // eslint-disable-next-line\n\n  if (!parentNode) return document.body;\n  switch (parentNode.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return parentNode.ownerDocument.body;\n    case '#document':\n      return parentNode.body;\n  } // If any of the overflow props is defined for the node then we return it as the parent\n\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getStyleComputedProperty(parentNode);\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return parentNode;\n  }\n  return getScrollParent(parentNode);\n};\nexport const hasScrollParent = node => {\n  var _a;\n  const scrollParentElement = getScrollParent(node);\n  return scrollParentElement ? scrollParentElement !== ((_a = scrollParentElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.body) : false;\n};","map":{"version":3,"mappings":"AAAA;;;;AAIG;AACH,OAAO,MAAMA,aAAa,GAAIC,IAAD,IAAmC;EAC9D,IAAIA,IAAI,CAACC,QAAL,KAAkB,MAAtB,EAA8B;IAC5B,OAAOD,IAAP;EACD,CAH6D,CAI9D;;EACA,OAAOA,IAAI,CAACE,UAAL,IAAoBF,IAAY,CAACG,IAAxC;AACD,CANM;AAQP;;;;AAIG;;AACH,MAAMC,wBAAwB,GAAIJ,IAAD,IAAoD;;EACnF,IAAIA,IAAI,CAACK,QAAL,KAAkB,CAAtB,EAAyB;IACvB,OAAO,EAAP;EACD;EAED,MAAMC,MAAM,GAAG,UAAI,CAACC,aAAL,MAAkB,IAAlB,IAAkBC,aAAlB,GAAkB,MAAlB,GAAkBA,GAAEC,WAAnC;EACA,OAAOH,MAAO,CAACI,gBAAR,CAAyBV,IAAzB,EAA+B,IAA/B,CAAP;AACD,CAPD;AASA;;;;AAIG;;AACH,OAAO,MAAMW,eAAe,GAAIX,IAAD,IAAqD;EAClF;EACA,MAAME,UAAU,GAAGF,IAAI,IAAID,aAAa,CAACC,IAAD,CAAxC,CAFkF,CAGlF;;EACA,IAAI,CAACE,UAAL,EAAiB,OAAOU,QAAQ,CAACC,IAAhB;EAEjB,QAAQX,UAAU,CAACD,QAAnB;IACE,KAAK,MAAL;IACA,KAAK,MAAL;MACE,OAAOC,UAAU,CAACK,aAAX,CAA0BM,IAAjC;IACF,KAAK,WAAL;MACE,OAASX,UAAmC,CAACW,IAA7C;EAAA,CAX8E,CAclF;;EACA,MAAM;IAAEC,QAAF;IAAYC,SAAZ;IAAuBC;EAAvB,IAAqCZ,wBAAwB,CAACF,UAAD,CAAnE;EACA,IAAI,wBAAwBe,IAAxB,CAA6BH,QAAS,GAAGE,SAAZ,GAAyBD,SAAtD,CAAJ,EAAsE;IACpE,OAAOb,UAAP;EACD;EAED,OAAOS,eAAe,CAACT,UAAD,CAAtB;AACD,CArBM;AAuBP,OAAO,MAAMgB,eAAe,GAAIlB,IAAD,IAAiD;;EAC9E,MAAMmB,mBAAmB,GAAgBR,eAAe,CAACX,IAAD,CAAxD;EACA,OAAOmB,mBAAmB,GAAGA,mBAAmB,MAAK,yBAAmB,CAACZ,aAApB,MAAiC,IAAjC,IAAiCC,aAAjC,GAAiC,MAAjC,GAAiCA,GAAEK,IAAxC,CAAtB,GAAqE,KAA/F;AACD,CAHM","names":["getParentNode","node","nodeName","parentNode","host","getStyleComputedProperty","nodeType","window","ownerDocument","_a","defaultView","getComputedStyle","getScrollParent","document","body","overflow","overflowX","overflowY","test","hasScrollParent","scrollParentElement"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-positioning\\lib\\src\\packages\\react-components\\react-positioning\\src\\utils\\getScrollParent.ts"],"sourcesContent":["/**\n * Returns the parent node or the host of the node argument.\n * @param node - DOM node.\n * @returns - parent DOM node.\n */\nexport const getParentNode = (node: HTMLElement): HTMLElement => {\n  if (node.nodeName === 'HTML') {\n    return node;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return node.parentNode || (node as any).host;\n};\n\n/**\n * Returns CSS styles of the given node.\n * @param node - DOM node.\n * @returns - CSS styles.\n */\nconst getStyleComputedProperty = (node: HTMLElement): Partial<CSSStyleDeclaration> => {\n  if (node.nodeType !== 1) {\n    return {};\n  }\n\n  const window = node.ownerDocument?.defaultView;\n  return window!.getComputedStyle(node, null);\n};\n\n/**\n * Returns the first scrollable parent of the given element.\n * @param node - DOM node.\n * @returns - the first scrollable parent.\n */\nexport const getScrollParent = (node: Document | HTMLElement | null): HTMLElement => {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  const parentNode = node && getParentNode(node as HTMLElement);\n  // eslint-disable-next-line\n  if (!parentNode) return document.body;\n\n  switch (parentNode.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return parentNode.ownerDocument!.body;\n    case '#document':\n      return ((parentNode as unknown) as Document).body;\n  }\n\n  // If any of the overflow props is defined for the node then we return it as the parent\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(parentNode);\n  if (/(auto|scroll|overlay)/.test(overflow! + overflowY! + overflowX)) {\n    return parentNode;\n  }\n\n  return getScrollParent(parentNode);\n};\n\nexport const hasScrollParent = (node: Document | HTMLElement | null): boolean => {\n  const scrollParentElement: HTMLElement = getScrollParent(node);\n  return scrollParentElement ? scrollParentElement !== scrollParentElement.ownerDocument?.body : false;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}