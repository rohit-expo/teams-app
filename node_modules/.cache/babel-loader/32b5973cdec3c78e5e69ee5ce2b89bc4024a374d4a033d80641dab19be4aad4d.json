{"ast":null,"code":"import { KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\nimport { FOCUS_VISIBLE_ATTR } from './constants';\n/**\n * @internal\n * @param scope - Applies the ponyfill to all DOM children\n * @param win - window\n */\n\nexport function applyFocusVisiblePolyfill(scope, win) {\n  if (alreadyInScope(scope)) {\n    // Focus visible polyfill already applied at this scope\n    return () => undefined;\n  }\n  const state = {\n    current: undefined\n  };\n  const keyborg = createKeyborg(win); // When navigation mode changes remove the focus-visible selector\n\n  keyborg.subscribe(isNavigatingWithKeyboard => {\n    if (!isNavigatingWithKeyboard && state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n  }); // Keyborg's focusin event is delegated so it's only registered once on the window\n  // and contains metadata about the focus event\n\n  const keyborgListener = e => {\n    if (state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {\n      // Griffel can't create chained global styles so use the parent element for now\n      state.current = e.target;\n      applyFocusVisibleClass(state.current);\n    }\n  }; // Make sure that when focus leaves the scope, the focus visible class is removed\n\n  const blurListener = e => {\n    if (!e.relatedTarget || isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget)) {\n      if (state.current) {\n        removeFocusVisibleClass(state.current);\n        state.current = undefined;\n      }\n    }\n  };\n  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);\n  scope.addEventListener('focusout', blurListener);\n  scope.focusVisible = true; // Return disposer\n\n  return () => {\n    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);\n    scope.removeEventListener('focusout', blurListener);\n    delete scope.focusVisible;\n    disposeKeyborg(keyborg);\n  };\n}\nfunction applyFocusVisibleClass(el) {\n  el.setAttribute(FOCUS_VISIBLE_ATTR, '');\n}\nfunction removeFocusVisibleClass(el) {\n  el.removeAttribute(FOCUS_VISIBLE_ATTR);\n}\nfunction isHTMLElement(target) {\n  if (!target) {\n    return false;\n  }\n  return Boolean(target && typeof target === 'object' && 'classList' in target && 'contains' in target);\n}\nfunction alreadyInScope(el) {\n  if (!el) {\n    return false;\n  }\n  if (el.focusVisible) {\n    return true;\n  }\n  return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);\n}","map":{"version":3,"mappings":"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","names":["KEYBORG_FOCUSIN","createKeyborg","disposeKeyborg","FOCUS_VISIBLE_ATTR","applyFocusVisiblePolyfill","scope","win","alreadyInScope","undefined","state","current","keyborg","subscribe","isNavigatingWithKeyboard","removeFocusVisibleClass","keyborgListener","e","isHTMLElement","target","applyFocusVisibleClass","blurListener","relatedTarget","contains","addEventListener","focusVisible","removeEventListener","el","setAttribute","removeAttribute","Boolean","parentElement"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-tabster\\lib\\src\\packages\\react-components\\react-tabster\\src\\focus\\focusVisiblePolyfill.ts"],"sourcesContent":["import { KEYBORG_FOCUSIN, KeyborgFocusInEvent, createKeyborg, disposeKeyborg } from 'keyborg';\nimport { FOCUS_VISIBLE_ATTR } from './constants';\n\n/**\n * Because `addEventListener` type override falls back to 2nd definition (evt name is unknown string literal)\n * evt is being typed as a base class of MouseEvent -> `Event`.\n * This type is used to override `listener` calls to make TS happy\n */\ntype ListenerOverride = (evt: Event) => void;\n\ntype FocusVisibleState = {\n  /**\n   * Current element with focus visible in state\n   */\n  current: HTMLElement | undefined;\n};\n\ntype HTMLElementWithFocusVisibleScope = {\n  focusVisible: boolean | undefined;\n} & HTMLElement;\n\n/**\n * @internal\n * @param scope - Applies the ponyfill to all DOM children\n * @param win - window\n */\nexport function applyFocusVisiblePolyfill(scope: HTMLElement, win: Window): () => void {\n  if (alreadyInScope(scope)) {\n    // Focus visible polyfill already applied at this scope\n    return () => undefined;\n  }\n\n  const state: FocusVisibleState = {\n    current: undefined,\n  };\n\n  const keyborg = createKeyborg(win);\n\n  // When navigation mode changes remove the focus-visible selector\n  keyborg.subscribe(isNavigatingWithKeyboard => {\n    if (!isNavigatingWithKeyboard && state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n  });\n\n  // Keyborg's focusin event is delegated so it's only registered once on the window\n  // and contains metadata about the focus event\n  const keyborgListener = (e: KeyborgFocusInEvent) => {\n    if (state.current) {\n      removeFocusVisibleClass(state.current);\n      state.current = undefined;\n    }\n\n    if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e.target) && e.target) {\n      // Griffel can't create chained global styles so use the parent element for now\n      state.current = e.target;\n      applyFocusVisibleClass(state.current);\n    }\n  };\n\n  // Make sure that when focus leaves the scope, the focus visible class is removed\n  const blurListener = (e: FocusEvent) => {\n    if (!e.relatedTarget || (isHTMLElement(e.relatedTarget) && !scope.contains(e.relatedTarget))) {\n      if (state.current) {\n        removeFocusVisibleClass(state.current);\n        state.current = undefined;\n      }\n    }\n  };\n\n  scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener as ListenerOverride);\n  scope.addEventListener('focusout', blurListener);\n  (scope as HTMLElementWithFocusVisibleScope).focusVisible = true;\n\n  // Return disposer\n  return () => {\n    scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener as ListenerOverride);\n    scope.removeEventListener('focusout', blurListener);\n    delete (scope as HTMLElementWithFocusVisibleScope).focusVisible;\n    disposeKeyborg(keyborg);\n  };\n}\n\nfunction applyFocusVisibleClass(el: HTMLElement) {\n  el.setAttribute(FOCUS_VISIBLE_ATTR, '');\n}\n\nfunction removeFocusVisibleClass(el: HTMLElement) {\n  el.removeAttribute(FOCUS_VISIBLE_ATTR);\n}\n\nfunction isHTMLElement(target: EventTarget | null): target is HTMLElement {\n  if (!target) {\n    return false;\n  }\n  return Boolean(target && typeof target === 'object' && 'classList' in target && 'contains' in target);\n}\n\nfunction alreadyInScope(el: HTMLElement | null | undefined): boolean {\n  if (!el) {\n    return false;\n  }\n\n  if ((el as HTMLElementWithFocusVisibleScope).focusVisible) {\n    return true;\n  }\n\n  return alreadyInScope(el?.parentElement);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}