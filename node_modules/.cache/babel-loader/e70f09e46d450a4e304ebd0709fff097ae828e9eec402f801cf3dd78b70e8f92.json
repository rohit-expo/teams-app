{"ast":null,"code":"/*! @azure/msal-common v13.2.0 2023-07-05 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __spreadArrays } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { Separators, AADServerParamKeys, AuthenticationScheme, GrantType, PromptValue, HeaderNames } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { RequestValidator } from '../request/RequestValidator.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\nvar AuthorizationCodeClient = /** @class */function (_super) {\n  __extends(AuthorizationCodeClient, _super);\n  function AuthorizationCodeClient(configuration, performanceClient) {\n    var _this = _super.call(this, configuration, performanceClient) || this;\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    _this.includeRedirectUri = true;\n    return _this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            return [4 /*yield*/, this.createAuthCodeUrlQueryString(request)];\n          case 1:\n            queryString = _c.sent();\n            return [2 /*return*/, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n        }\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    var _a, _b, _c, _d, _e, _f;\n    return __awaiter(this, void 0, void 0, function () {\n      var atsMeasurement, reqTimestamp, response, requestId, httpVerAuthority, responseHandler;\n      var _this = this;\n      return __generator(this, function (_g) {\n        switch (_g.label) {\n          case 0:\n            if (!request || !request.code) {\n              throw ClientAuthError.createTokenRequestCannotBeMadeError();\n            }\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n            atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\n            this.logger.info(\"in acquireToken call in auth-code client\");\n            reqTimestamp = TimeUtils.nowSeconds();\n            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            return [4 /*yield*/, this.executeTokenRequest(this.authority, request)];\n          case 1:\n            response = _g.sent();\n            requestId = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_REQUEST_ID];\n            httpVerAuthority = (_e = response.headers) === null || _e === void 0 ? void 0 : _e[HeaderNames.X_MS_HTTP_VERSION];\n            if (httpVerAuthority) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({\n                httpVerAuthority: httpVerAuthority\n              });\n            }\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\n            // Validate response. This function throws a server error if an error is returned by the server.\n            responseHandler.validateTokenResponse(response.body);\n            (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\n            return [2 /*return*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId).then(function (result) {\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                success: true\n              });\n              return result;\n            }).catch(function (error) {\n              _this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\n              atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({\n                errorCode: error.errorCode,\n                subErrorCode: error.subError,\n                success: false\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n    // Deserialize hash fragment response parameters.\n    var hashUrlString = new UrlString(hashFragment);\n    // Deserialize hash fragment response parameters.\n    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());\n    // Get code response\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n      throw ClientAuthError.createNoAuthCodeInServerResponseError();\n    }\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError.createEmptyLogoutRequestError();\n    }\n    var queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var queryParametersString, endpoint, requestBody, ccsCredential, clientInfo, headers, thumbprint;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            queryParametersString = this.createTokenQueryParameters(request);\n            endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n            return [4 /*yield*/, this.createTokenRequestBody(request)];\n          case 1:\n            requestBody = _c.sent();\n            ccsCredential = undefined;\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [2 /*return*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;\n      var _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            /*\r\n             * For hybrid spa flow, there will be a code but no verifier\r\n             * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n             */\n            if (!this.includeRedirectUri) {\n              // Just validate\n              RequestValidator.validateRedirectUri(request.redirectUri);\n            } else {\n              // Validate and include redirect uri\n              parameterBuilder.addRedirectUri(request.redirectUri);\n            }\n            // Add scope array, parameter builder will add default scopes and dedupe\n            parameterBuilder.addScopes(request.scopes);\n            // add code: user set, not validated\n            parameterBuilder.addAuthorizationCode(request.code);\n            // Add library metadata\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n            parameterBuilder.addThrottling();\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            }\n            // add code_verifier if passed\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n            (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\n            return [4 /*yield*/, popTokenGenerator.generateCnf(request)];\n          case 1:\n            reqCnfData = _d.sent();\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n            return [3 /*break*/, 3];\n          case 2:\n            if (request.authenticationScheme === AuthenticationScheme.SSH) {\n              if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n              } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n              }\n            }\n            _d.label = 3;\n          case 3:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n            ccsCred = undefined;\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            }\n            // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n                  break;\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n            if (request.tokenBodyParameters) {\n              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n            }\n            // Add hybrid spa parameters if not already provided\n            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n              parameterBuilder.addExtraQueryParameters((_c = {}, _c[AADServerParamKeys.RETURN_SPA_CODE] = \"1\", _c));\n            }\n            return [2 /*return*/, parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n            parameterBuilder.addScopes(requestScopes);\n            // validate the redirectUri (to be a non null value)\n            parameterBuilder.addRedirectUri(request.redirectUri);\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n            // add response_mode. If not passed in it defaults to query.\n            parameterBuilder.addResponseMode(request.responseMode);\n            // add response_type = code\n            parameterBuilder.addResponseTypeCode();\n            // add library info parameters\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n            // add client_info=1\n            parameterBuilder.addClientInfo();\n            if (request.codeChallenge && request.codeChallengeMethod) {\n              parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n            }\n            if (request.prompt) {\n              parameterBuilder.addPrompt(request.prompt);\n            }\n            if (request.domainHint) {\n              parameterBuilder.addDomainHint(request.domainHint);\n            }\n            // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n            if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n              // AAD will throw if prompt=select_account is passed with an account hint\n              if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n              } else if (request.account) {\n                accountSid = this.extractAccountSid(request.account);\n                accountLoginHintClaim = this.extractLoginHint(request.account);\n                // If login_hint claim is present, use it over sid/username\n                if (accountLoginHintClaim) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n                  parameterBuilder.addLoginHint(accountLoginHintClaim);\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                  /*\r\n                   * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                   * SessionId is only used in silent calls\r\n                   */\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                  parameterBuilder.addSid(accountSid);\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                } else if (request.loginHint) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                  parameterBuilder.addLoginHint(request.loginHint);\n                  parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                  // Fallback to account username if provided\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                  parameterBuilder.addLoginHint(request.account.username);\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n                  }\n                }\n              } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n              }\n            } else {\n              this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n            }\n            if (request.nonce) {\n              parameterBuilder.addNonce(request.nonce);\n            }\n            if (request.state) {\n              parameterBuilder.addState(request.state);\n            }\n            if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n            if (request.extraQueryParameters) {\n              parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n            }\n            if (!request.nativeBroker) return [3 /*break*/, 2];\n            // signal ests that this is a WAM call\n            parameterBuilder.addNativeBroker();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4 /*yield*/, popTokenGenerator.generateCnf(request)];\n          case 1:\n            reqCnfData = _b.sent();\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n            _b.label = 2;\n          case 2:\n            return [2 /*return*/, parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    var _a;\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;\n  };\n  AuthorizationCodeClient.prototype.extractLoginHint = function (account) {\n    var _a;\n    return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;\n  };\n  return AuthorizationCodeClient;\n}(BaseClient);\nexport { AuthorizationCodeClient };","map":{"version":3,"mappings":"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","names":["__extends","AuthorizationCodeClient","performanceClient","_super","_this","request","addQueueMeasurement","PerformanceEvents","GetAuthCodeUrl","correlationId","setPreQueueTime","AuthClientCreateQueryString","createAuthCodeUrlQueryString","queryString","_c","UrlString","appendQueryString","authority","authorizationEndpoint","authCodePayload","code","ClientAuthError","createTokenRequestCannotBeMadeError","AuthClientAcquireToken","atsMeasurement","logger","info","reqTimestamp","TimeUtils","nowSeconds","AuthClientExecuteTokenRequest","executeTokenRequest","response","_g","requestId","headers","HeaderNames","X_MS_REQUEST_ID","httpVerAuthority","X_MS_HTTP_VERSION","addStaticFields","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","HandleServerTokenResponse","handleServerTokenResponse","undefined","then","result","endMeasurement","success","catch","error","verbose","errorCode","subErrorCode","subError","hashFragment","cachedState","hashUrlString","serverParams","getDeserializedHash","getHash","validateServerAuthorizationCodeResponse","createNoAuthCodeInServerResponseError","logoutRequest","ClientConfigurationError","createEmptyLogoutRequestError","createLogoutUrlQueryString","endSessionEndpoint","AuthClientCreateTokenRequestBody","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","createTokenRequestBody","requestBody","ccsCredential","clientInfo","buildClientInfo","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","createTokenRequestHeaders","thumbprint","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","addClientId","includeRedirectUri","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","PopTokenGenerateCnf","generateCnf","reqCnfData","_d","addPopToken","reqCnfString","SSH","sshJwk","addSshJwk","createMissingSshJwkError","cryptoInterface","createNewGuid","addCorrelationId","StringUtils","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","tokenBodyParameters","addExtraQueryParameters","enableSpaAuthorizationCode","AADServerParamKeys","RETURN_SPA_CODE","createQueryString","requestScopes","__spreadArrays","extraScopesToConsent","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","addLoginHint","homeAccountId","loginHint","username","nonce","addNonce","state","addState","isEmpty","extraQueryParameters","nativeBroker","addNativeBroker","_b","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","idTokenClaims","login_hint","BaseClient"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@azure\\msal-common\\src\\client\\AuthorizationCodeClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\r\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\r\nimport { GrantType, AuthenticationScheme, PromptValue, Separators, AADServerParamKeys, HeaderNames } from \"../utils/Constants\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\r\nimport { NetworkResponse } from \"../network/NetworkManager\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { UrlString } from \"../url/UrlString\";\r\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\r\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\r\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from \"../account/ClientInfo\";\r\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { RequestValidator } from \"../request/RequestValidator\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\n\r\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\r\nexport class AuthorizationCodeClient extends BaseClient {\r\n    // Flag to indicate if client is for hybrid spa auth code redemption\r\n    protected includeRedirectUri: boolean = true;\r\n\r\n    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient) {\r\n        super(configuration, performanceClient);\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n     * application. The URL target the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * acquireToken(AuthorizationCodeRequest)\r\n     * @param request\r\n     */\r\n    async getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\r\n\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\r\n        const queryString = await this.createAuthCodeUrlQueryString(request);\r\n\r\n        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n     * authorization_code_grant\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult> {\r\n        if (!request || !request.code) {\r\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\r\n        }\r\n\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\r\n        \r\n        // @ts-ignore\r\n        const atsMeasurement = this.performanceClient?.startMeasurement(\"AuthCodeClientAcquireToken\", request.correlationId);\r\n        this.logger.info(\"in acquireToken call in auth-code client\");\r\n\r\n        const reqTimestamp = TimeUtils.nowSeconds();\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\r\n        const response = await this.executeTokenRequest(this.authority, request);\r\n\r\n        // Retrieve requestId from response headers\r\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\r\n        const httpVerAuthority = response.headers?.[HeaderNames.X_MS_HTTP_VERSION];\r\n        if(httpVerAuthority)\r\n        {\r\n            atsMeasurement?.addStaticFields({\r\n                httpVerAuthority\r\n            });\r\n        }\r\n        const responseHandler = new ResponseHandler(\r\n            this.config.authOptions.clientId,\r\n            this.cacheManager,\r\n            this.cryptoUtils,\r\n            this.logger,\r\n            this.config.serializableCache,\r\n            this.config.persistencePlugin,\r\n            this.performanceClient\r\n        );\r\n\r\n        // Validate response. This function throws a server error if an error is returned by the server.\r\n        responseHandler.validateTokenResponse(response.body);\r\n\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\r\n        return responseHandler.handleServerTokenResponse(\r\n            response.body,\r\n            this.authority,\r\n            reqTimestamp,\r\n            request,\r\n            authCodePayload,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            requestId\r\n        ).then((result: AuthenticationResult) => {\r\n            atsMeasurement?.endMeasurement({\r\n                success: true\r\n            });\r\n            return result;\r\n        })\r\n            .catch((error) => {\r\n                this.logger.verbose(\"Error in fetching token in ACC\", request.correlationId);\r\n                atsMeasurement?.endMeasurement({\r\n                    errorCode: error.errorCode,\r\n                    subErrorCode: error.subError,\r\n                    success: false\r\n                });\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Handles the hash fragment response from public client code request. Returns a code response used by\r\n     * the client to exchange for a token in acquireToken.\r\n     * @param hashFragment\r\n     */\r\n    handleFragmentResponse(hashFragment: string, cachedState: string): AuthorizationCodePayload {\r\n        // Handle responses.\r\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\r\n\r\n        // Deserialize hash fragment response parameters.\r\n        const hashUrlString = new UrlString(hashFragment);\r\n        // Deserialize hash fragment response parameters.\r\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hashUrlString.getHash());\r\n\r\n        // Get code response\r\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\r\n\r\n        // throw when there is no auth code in the response\r\n        if (!serverParams.code) {\r\n            throw ClientAuthError.createNoAuthCodeInServerResponseError();\r\n        }\r\n        return {\r\n            ...serverParams,\r\n            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\r\n            code: serverParams.code\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param authorityUri\r\n     */\r\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\r\n        // Throw error if logoutRequest is null/undefined\r\n        if (!logoutRequest) {\r\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\r\n        }\r\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\r\n\r\n        // Construct logout URI\r\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\r\n    }\r\n\r\n    /**\r\n     * Executes POST request to token endpoint\r\n     * @param authority\r\n     * @param request\r\n     */\r\n    private async executeTokenRequest(authority: Authority, request: CommonAuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\r\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\r\n        \r\n        const queryParametersString = this.createTokenQueryParameters(request);\r\n        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n        \r\n        const requestBody = await this.createTokenRequestBody(request);\r\n        \r\n        let ccsCredential: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCredential = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        }\r\n        const headers: Record<string, string> = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\r\n\r\n        const thumbprint: RequestThumbprint = {\r\n            clientId: this.config.authOptions.clientId,\r\n            authority: authority.canonicalAuthority,\r\n            scopes: request.scopes,\r\n            claims: request.claims,\r\n            authenticationScheme: request.authenticationScheme,\r\n            resourceRequestMethod: request.resourceRequestMethod,\r\n            resourceRequestUri: request.resourceRequestUri,\r\n            shrClaims: request.shrClaims,\r\n            sshKid: request.sshKid\r\n        };\r\n\r\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\r\n    }\r\n\r\n    /**\r\n     * Generates a map for all the params to be sent to the service\r\n     * @param request\r\n     */\r\n    private async createTokenRequestBody(request: CommonAuthorizationCodeRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\r\n\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        /*\r\n         * For hybrid spa flow, there will be a code but no verifier\r\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n         */\r\n        if (!this.includeRedirectUri) {\r\n            // Just validate\r\n            RequestValidator.validateRedirectUri(request.redirectUri);\r\n        } else {\r\n            // Validate and include redirect uri\r\n            parameterBuilder.addRedirectUri(request.redirectUri);\r\n        }\r\n\r\n        // Add scope array, parameter builder will add default scopes and dedupe\r\n        parameterBuilder.addScopes(request.scopes);\r\n\r\n        // add code: user set, not validated\r\n        parameterBuilder.addAuthorizationCode(request.code);\r\n\r\n        // Add library metadata\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n        parameterBuilder.addThrottling();\r\n\r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n\r\n        // add code_verifier if passed\r\n        if (request.codeVerifier) {\r\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n\r\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\r\n\r\n            this.performanceClient?.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\r\n            const reqCnfData = await popTokenGenerator.generateCnf(request);\r\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\r\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\r\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\r\n            if (request.sshJwk) {\r\n                parameterBuilder.addSshJwk(request.sshJwk);\r\n            } else {\r\n                throw ClientConfigurationError.createMissingSshJwkError();\r\n            }\r\n        }\r\n\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        let ccsCred: CcsCredential | undefined = undefined;\r\n        if (request.clientInfo) {\r\n            try {\r\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\r\n                ccsCred = {\r\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\r\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\r\n                };\r\n            } catch (e) {\r\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\r\n            }\r\n        } else {\r\n            ccsCred = request.ccsCredential;\r\n        }\r\n\r\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\r\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\r\n            switch (ccsCred.type) {\r\n                case CcsCredentialType.HOME_ACCOUNT_ID:\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\r\n                    }\r\n                    break;\r\n                case CcsCredentialType.UPN:\r\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (request.tokenBodyParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\r\n        }\r\n\r\n        // Add hybrid spa parameters if not already provided\r\n        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\r\n            parameterBuilder.addExtraQueryParameters({\r\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\"\r\n            });\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private async createAuthCodeUrlQueryString(request: CommonAuthorizationUrlRequest): Promise<string> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\r\n\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n\r\n        const requestScopes = [...request.scopes || [], ...request.extraScopesToConsent || []];\r\n        parameterBuilder.addScopes(requestScopes);\r\n\r\n        // validate the redirectUri (to be a non null value)\r\n        parameterBuilder.addRedirectUri(request.redirectUri);\r\n\r\n        // generate the correlationId if not set by the user and add\r\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n\r\n        // add response_mode. If not passed in it defaults to query.\r\n        parameterBuilder.addResponseMode(request.responseMode);\r\n\r\n        // add response_type = code\r\n        parameterBuilder.addResponseTypeCode();\r\n\r\n        // add library info parameters\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n\r\n        // add client_info=1\r\n        parameterBuilder.addClientInfo();\r\n\r\n        if (request.codeChallenge && request.codeChallengeMethod) {\r\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\r\n        }\r\n\r\n        if (request.prompt) {\r\n            parameterBuilder.addPrompt(request.prompt);\r\n        }\r\n\r\n        if (request.domainHint) {\r\n            parameterBuilder.addDomainHint(request.domainHint);\r\n        }\r\n\r\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\r\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\r\n            // AAD will throw if prompt=select_account is passed with an account hint\r\n            if (request.sid && request.prompt === PromptValue.NONE) {\r\n                // SessionID is only used in silent calls\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\r\n                parameterBuilder.addSid(request.sid);\r\n            } else if (request.account) {\r\n                const accountSid = this.extractAccountSid(request.account);\r\n                const accountLoginHintClaim = this.extractLoginHint(request.account);\r\n                // If login_hint claim is present, use it over sid/username\r\n                if (accountLoginHintClaim) {\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\r\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\r\n                    /*\r\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n                     * SessionId is only used in silent calls\r\n                     */\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\r\n                    parameterBuilder.addSid(accountSid);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                } else if (request.loginHint) {\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\r\n                    parameterBuilder.addLoginHint(request.loginHint);\r\n                    parameterBuilder.addCcsUpn(request.loginHint);\r\n                } else if (request.account.username) {\r\n                    // Fallback to account username if provided\r\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\r\n                    parameterBuilder.addLoginHint(request.account.username);\r\n                    try {\r\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\r\n                        parameterBuilder.addCcsOid(clientInfo);\r\n                    } catch (e) {\r\n                        this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\r\n                    }\r\n                }\r\n            } else if (request.loginHint) {\r\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\r\n                parameterBuilder.addLoginHint(request.loginHint);\r\n                parameterBuilder.addCcsUpn(request.loginHint);\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\r\n        }\r\n\r\n        if (request.nonce) {\r\n            parameterBuilder.addNonce(request.nonce);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        if (request.nativeBroker) {\r\n            // signal ests that this is a WAM call\r\n            parameterBuilder.addNativeBroker();\r\n\r\n            // pass the req_cnf for POP\r\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\r\n                const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\r\n                // to reduce the URL length, it is recommended to send the short form of the req_cnf\r\n                const reqCnfData = await popTokenGenerator.generateCnf(request);\r\n                parameterBuilder.addPopToken(reqCnfData.reqCnfString);\r\n            }\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * This API validates the `EndSessionRequest` and creates a URL\r\n     * @param request\r\n     */\r\n    private createLogoutUrlQueryString(request: CommonEndSessionRequest): string {\r\n        const parameterBuilder = new RequestParameterBuilder();\r\n\r\n        if (request.postLogoutRedirectUri) {\r\n            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\r\n        }\r\n\r\n        if (request.correlationId) {\r\n            parameterBuilder.addCorrelationId(request.correlationId);\r\n        }\r\n\r\n        if (request.idTokenHint) {\r\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\r\n        }\r\n\r\n        if (request.state) {\r\n            parameterBuilder.addState(request.state);\r\n        }\r\n\r\n        if (request.logoutHint) {\r\n            parameterBuilder.addLogoutHint(request.logoutHint);\r\n        }\r\n\r\n        if (request.extraQueryParameters) {\r\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\r\n        }\r\n\r\n        return parameterBuilder.createQueryString();\r\n    }\r\n\r\n    /**\r\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n     * @param account\r\n     */\r\n    private extractAccountSid(account: AccountInfo): string | null {\r\n        return account.idTokenClaims?.sid || null;\r\n    }\r\n\r\n    private extractLoginHint(account: AccountInfo): string | null {\r\n        return account.idTokenClaims?.login_hint || null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}