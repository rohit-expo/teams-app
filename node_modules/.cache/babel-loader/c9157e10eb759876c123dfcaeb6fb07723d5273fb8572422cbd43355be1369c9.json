{"ast":null,"code":"import { computePosition } from '@floating-ui/dom';\nimport { debounce, writeArrowUpdates, writeContainerUpdates, getScrollParent } from './utils';\n/**\n * @internal\n * @returns manager that handles positioning out of the react lifecycle\n */\n\nexport function createPositionManager(options) {\n  const {\n    container,\n    target,\n    arrow,\n    strategy,\n    middleware,\n    placement\n  } = options;\n  if (!target || !container) {\n    return {\n      updatePosition: () => undefined,\n      dispose: () => undefined\n    };\n  }\n  let isFirstUpdate = true;\n  const scrollParents = new Set();\n  const targetWindow = container.ownerDocument.defaultView; // When the container is first resolved, set position `fixed` to avoid scroll jumps.\n  // Without this scroll jumps can occur when the element is rendered initially and receives focus\n\n  Object.assign(container.style, {\n    position: 'fixed',\n    left: 0,\n    top: 0,\n    margin: 0\n  });\n  const forceUpdate = () => {\n    if (isFirstUpdate) {\n      scrollParents.add(getScrollParent(container));\n      if (target instanceof HTMLElement) {\n        scrollParents.add(getScrollParent(target));\n      }\n      scrollParents.forEach(scrollParent => {\n        scrollParent.addEventListener('scroll', updatePosition);\n      });\n      isFirstUpdate = false;\n    }\n    Object.assign(container.style, {\n      position: strategy\n    });\n    computePosition(target, container, {\n      placement,\n      middleware,\n      strategy\n    }).then(_ref => {\n      let {\n        x,\n        y,\n        middlewareData,\n        placement: computedPlacement\n      } = _ref;\n      writeArrowUpdates({\n        arrow,\n        middlewareData\n      });\n      writeContainerUpdates({\n        container,\n        middlewareData,\n        placement: computedPlacement,\n        coordinates: {\n          x,\n          y\n        },\n        lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,\n        strategy\n      });\n    }).catch(err => {\n      // https://github.com/floating-ui/floating-ui/issues/1845\n      // FIXME for node > 14\n      // node 15 introduces promise rejection which means that any components\n      // tests need to be `it('', async () => {})` otherwise there can be race conditions with\n      // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist\n      // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing\n      // will actually be counter productive\n      if (process.env.NODE_ENV === 'development') {\n        // eslint-disable-next-line no-console\n        console.error('[usePositioning]: Failed to calculate position', err);\n      }\n    });\n  };\n  const updatePosition = debounce(() => forceUpdate());\n  const dispose = () => {\n    if (targetWindow) {\n      targetWindow.removeEventListener('scroll', updatePosition);\n      targetWindow.removeEventListener('resize', updatePosition);\n    }\n    scrollParents.forEach(scrollParent => {\n      scrollParent.removeEventListener('scroll', updatePosition);\n    });\n  };\n  if (targetWindow) {\n    targetWindow.addEventListener('scroll', updatePosition);\n    targetWindow.addEventListener('resize', updatePosition);\n  } // Update the position on initialization\n\n  updatePosition();\n  return {\n    updatePosition,\n    dispose\n  };\n}","map":{"version":3,"mappings":"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","names":["computePosition","debounce","writeArrowUpdates","writeContainerUpdates","getScrollParent","createPositionManager","options","container","target","arrow","strategy","middleware","placement","updatePosition","undefined","dispose","isFirstUpdate","scrollParents","Set","targetWindow","ownerDocument","defaultView","Object","assign","style","position","left","top","margin","forceUpdate","add","HTMLElement","forEach","scrollParent","addEventListener","then","x","y","middlewareData","computedPlacement","coordinates","lowPPI","devicePixelRatio","catch","err","process","env","NODE_ENV","console","error","removeEventListener"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-positioning\\src\\packages\\react-components\\react-positioning\\src\\createPositionManager.ts"],"sourcesContent":["import { computePosition } from '@floating-ui/dom';\nimport type { Middleware, Placement, Strategy } from '@floating-ui/dom';\nimport type { PositionManager, TargetElement } from './types';\nimport { debounce, writeArrowUpdates, writeContainerUpdates, getScrollParent } from './utils';\n\ninterface PositionManagerOptions {\n  /**\n   * The positioned element\n   */\n  container: HTMLElement;\n  /**\n   * Element that the container will be anchored to\n   */\n  target: TargetElement;\n  /**\n   * Arrow that points from the container to the target\n   */\n  arrow: HTMLElement | null;\n  /**\n   * The value of the css `position` property\n   * @default absolute\n   */\n  strategy: Strategy;\n  /**\n   * [Floating UI middleware](https://floating-ui.com/docs/middleware)\n   */\n  middleware: Middleware[];\n  /**\n   * [Floating UI placement](https://floating-ui.com/docs/computePosition#placement)\n   */\n  placement?: Placement;\n}\n\n/**\n * @internal\n * @returns manager that handles positioning out of the react lifecycle\n */\nexport function createPositionManager(options: PositionManagerOptions): PositionManager {\n  const { container, target, arrow, strategy, middleware, placement } = options;\n  if (!target || !container) {\n    return {\n      updatePosition: () => undefined,\n      dispose: () => undefined,\n    };\n  }\n\n  let isFirstUpdate = true;\n  const scrollParents: Set<HTMLElement> = new Set<HTMLElement>();\n  const targetWindow = container.ownerDocument.defaultView;\n\n  // When the container is first resolved, set position `fixed` to avoid scroll jumps.\n  // Without this scroll jumps can occur when the element is rendered initially and receives focus\n  Object.assign(container.style, { position: 'fixed', left: 0, top: 0, margin: 0 });\n\n  const forceUpdate = () => {\n    if (isFirstUpdate) {\n      scrollParents.add(getScrollParent(container));\n      if (target instanceof HTMLElement) {\n        scrollParents.add(getScrollParent(target));\n      }\n\n      scrollParents.forEach(scrollParent => {\n        scrollParent.addEventListener('scroll', updatePosition);\n      });\n\n      isFirstUpdate = false;\n    }\n\n    Object.assign(container.style, { position: strategy });\n    computePosition(target, container, { placement, middleware, strategy })\n      .then(({ x, y, middlewareData, placement: computedPlacement }) => {\n        writeArrowUpdates({ arrow, middlewareData });\n        writeContainerUpdates({\n          container,\n          middlewareData,\n          placement: computedPlacement,\n          coordinates: { x, y },\n          lowPPI: (targetWindow?.devicePixelRatio || 1) <= 1,\n          strategy,\n        });\n      })\n      .catch(err => {\n        // https://github.com/floating-ui/floating-ui/issues/1845\n        // FIXME for node > 14\n        // node 15 introduces promise rejection which means that any components\n        // tests need to be `it('', async () => {})` otherwise there can be race conditions with\n        // JSDOM being torn down before this promise is resolved so globals like `window` and `document` don't exist\n        // Unless all tests that ever use `usePositioning` are turned into async tests, any logging during testing\n        // will actually be counter productive\n        if (process.env.NODE_ENV === 'development') {\n          // eslint-disable-next-line no-console\n          console.error('[usePositioning]: Failed to calculate position', err);\n        }\n      });\n  };\n\n  const updatePosition = debounce(() => forceUpdate());\n\n  const dispose = () => {\n    if (targetWindow) {\n      targetWindow.removeEventListener('scroll', updatePosition);\n      targetWindow.removeEventListener('resize', updatePosition);\n    }\n\n    scrollParents.forEach(scrollParent => {\n      scrollParent.removeEventListener('scroll', updatePosition);\n    });\n  };\n\n  if (targetWindow) {\n    targetWindow.addEventListener('scroll', updatePosition);\n    targetWindow.addEventListener('resize', updatePosition);\n  }\n\n  // Update the position on initialization\n  updatePosition();\n\n  return {\n    updatePosition,\n    dispose,\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}