{"ast":null,"code":"/*! @azure/msal-common v13.2.0 2023-07-05 */\n'use strict';\n\nimport { __awaiter, __generator, __assign, __extends } from '../_virtual/_tslib.js';\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { name, version } from '../packageMetadata.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\nvar CacheManager = /** @class */function () {\n  function CacheManager(clientId, cryptoImpl, logger) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n    var allAccountKeys = this.getAccountKeys();\n    if (allAccountKeys.length < 1) {\n      return [];\n    }\n    var accountEntities = allAccountKeys.reduce(function (accounts, key) {\n      var entity = _this.getAccount(key);\n      if (!entity) {\n        return accounts;\n      }\n      accounts.push(entity);\n      return accounts;\n    }, []);\n    if (accountEntities.length < 1) {\n      return [];\n    } else {\n      var allAccounts = accountEntities.map(function (accountEntity) {\n        return _this.getAccountInfoFromEntity(accountEntity);\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * Gets accountInfo object based on provided filters\r\n   */\n  CacheManager.prototype.getAccountInfoFilteredBy = function (accountFilter) {\n    var allAccounts = this.getAccountsFilteredBy(accountFilter);\n    if (allAccounts.length > 0) {\n      return this.getAccountInfoFromEntity(allAccounts[0]);\n    } else {\n      return null;\n    }\n  };\n  CacheManager.prototype.getAccountInfoFromEntity = function (accountEntity) {\n    var accountInfo = accountEntity.getAccountInfo();\n    var idToken = this.getIdToken(accountInfo);\n    if (idToken) {\n      accountInfo.idToken = idToken.secret;\n      accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n    }\n    return accountInfo;\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n            if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            accessTokenFilter = {\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            };\n            tokenKeys = this.getTokenKeys();\n            currentScopes = ScopeSet.fromString(credential.target);\n            removedAccessTokens = [];\n            tokenKeys.accessToken.forEach(function (key) {\n              if (!_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n                return;\n              }\n              var tokenEntity = _this.getAccessTokenCredential(key);\n              if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                  removedAccessTokens.push(_this.removeAccessToken(key));\n                }\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedAccessTokens)];\n          case 1:\n            _a.sent();\n            this.setAccessTokenCredential(credential);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    var _this = this;\n    var allAccountKeys = this.getAccountKeys();\n    var matchingAccounts = [];\n    allAccountKeys.forEach(function (cacheKey) {\n      if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      var entity = _this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n   * @param key\r\n   * @param homeAccountId\r\n   * @param tenantId\r\n   * @returns\r\n   */\n  CacheManager.prototype.isAccountKey = function (key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  };\n  /**\r\n   * Returns true if the given key matches our credential key schema.\r\n   * @param key\r\n   */\n  CacheManager.prototype.isCredentialKey = function (key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    var lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      var clientIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;\n      var familyIdValidation = \"\" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Returns whether or not the given credential entity matches the filter\r\n   * @param entity\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.credentialMatchesFilter = function (entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\r\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\r\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allAccountKeys, removedAccounts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allAccountKeys = this.getAccountKeys();\n            removedAccounts = [];\n            allAccountKeys.forEach(function (cacheKey) {\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4 /*yield*/, Promise.all(removedAccounts)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the account and related tokens for a given account key\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            return [4 /*yield*/, this.removeAccountContext(account)];\n          case 1:\n            _a.sent();\n            this.removeItem(accountKey);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allTokenKeys, accountId, removedCredentials;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allTokenKeys = this.getTokenKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allTokenKeys.idToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeIdToken(key);\n              }\n            });\n            allTokenKeys.accessToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(_this.removeAccessToken(key));\n              }\n            });\n            allTokenKeys.refreshToken.forEach(function (key) {\n              if (key.indexOf(accountId) === 0) {\n                _this.removeRefreshToken(key);\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedCredentials)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n  CacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var credential, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            credential = this.getAccessTokenCredential(key);\n            if (!credential) {\n              return [2 /*return*/];\n            }\n\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n          case 4:\n            return [2 /*return*/, this.removeItem(key)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readCacheRecord = function (account, request, environment) {\n    var tokenKeys = this.getTokenKeys();\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.getIdToken(account, tokenKeys);\n    var cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\n    var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n  CacheManager.prototype.getIdToken = function (account, tokenKeys) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    var numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  };\n  /**\r\n   * Gets all idTokens matching the given filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.getIdTokensByFilter = function (filter, tokenKeys) {\n    var _this = this;\n    var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    var idTokens = [];\n    idTokenKeys.forEach(function (key) {\n      if (!_this.idTokenKeyMatchesFilter(key, __assign({\n        clientId: _this.clientId\n      }, filter))) {\n        return;\n      }\n      var idToken = _this.getIdTokenCredential(key);\n      if (idToken && _this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.idTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Removes idToken from the cache\r\n   * @param key\r\n   */\n  CacheManager.prototype.removeIdToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Removes refresh token from the cache\r\n   * @param key\r\n   */\n  CacheManager.prototype.removeRefreshToken = function (key) {\n    this.removeItem(key);\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.getAccessToken = function (account, request, tokenKeys) {\n    var _this = this;\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    var scopes = ScopeSet.createSearchScopes(request.scopes);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    var accessTokens = [];\n    accessTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        var accessToken = _this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   * @param keyMustContainAllScopes\r\n   * @returns\r\n   */\n  CacheManager.prototype.accessTokenKeyMatchesFilter = function (inputKey, filter, keyMustContainAllScopes) {\n    var key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      var scopes = filter.target.asArray();\n      for (var i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  };\n  /**\r\n   * Gets all access tokens matching the filter\r\n   * @param filter\r\n   * @returns\r\n   */\n  CacheManager.prototype.getAccessTokensByFilter = function (filter) {\n    var _this = this;\n    var tokenKeys = this.getTokenKeys();\n    var accessTokens = [];\n    tokenKeys.accessToken.forEach(function (key) {\n      if (!_this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      var accessToken = _this.getAccessTokenCredential(key);\n      if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n  CacheManager.prototype.getRefreshToken = function (account, familyRT, tokenKeys) {\n    var _this = this;\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    var refreshTokens = [];\n    refreshTokenKeys.forEach(function (key) {\n      // Validate key\n      if (_this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        var refreshToken = _this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    var numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  };\n  /**\r\n   * Validate the cache key against filter before retrieving and parsing cache value\r\n   * @param key\r\n   * @param filter\r\n   */\n  CacheManager.prototype.refreshTokenKeyMatchesFilter = function (inputKey, filter) {\n    var key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  CacheManager.prototype.readAppMetadataFromCache = function (environment) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: this.clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.isAppMetadataFOCI = function (environment) {\n    var appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param entity\r\n   * @param localAccountId\r\n   * @returns\r\n   */\n  CacheManager.prototype.matchLocalAccountId = function (entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  };\n  /**\r\n   * helper to match usernames\r\n   * @param entity\r\n   * @param username\r\n   * @returns\r\n   */\n  CacheManager.prototype.matchUsername = function (entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  };\n  return CacheManager;\n}();\nvar DefaultStorageClass = /** @class */function (_super) {\n  __extends(DefaultStorageClass, _super);\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccountKeys = function () {\n    var notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getTokenKeys = function () {\n    var notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  return DefaultStorageClass;\n}(CacheManager);\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"mappings":"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","names":["clientId","cryptoImpl","logger","commonLogger","clone","name","version","CacheManager","_this","allAccountKeys","getAccountKeys","length","accountEntities","reduce","accounts","key","entity","getAccount","push","allAccounts","map","accountEntity","getAccountInfoFromEntity","accountFilter","getAccountsFilteredBy","accountInfo","getAccountInfo","idToken","getIdToken","secret","idTokenClaims","AuthToken","claims","cacheRecord","ClientAuthError","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","_a","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","accessTokenFilter","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","tokenKeys","getTokenKeys","currentScopes","ScopeSet","fromString","target","removedAccessTokens","forEach","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","tokenScopeSet","intersectingScopeSets","removeAccessToken","Promise","all","setAccessTokenCredential","matchingAccounts","cacheKey","isAccountKey","matchHomeAccountId","localAccountId","matchLocalAccountId","username","matchUsername","matchEnvironment","matchRealm","nativeAccountId","matchNativeAccountId","tenantId","split","Separators","CACHE_KEY_SEPARATOR","toLowerCase","includes","lowerCaseKey","indexOf","CredentialType","ID_TOKEN","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","clientIdValidation","familyIdValidation","THE_FAMILY_ID","filter","matchClientId","userAssertionHash","matchUserAssertionHash","matchCredentialType","familyId","matchFamilyId","matchTarget","matchTokenType","AuthenticationScheme","SSH","keyId","matchKeyId","getAppMetadataFilteredByInternal","allCacheKeys","getKeys","matchingAppMetadata","isAppMetadata","getAppMetadata","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","getAuthorityMetadata","aliases","removedAccounts","removeAccount","accountKey","createNoAccountFoundError","removeAccountContext","removeItem","allTokenKeys","accountId","generateAccountId","removedCredentials","removeIdToken","removeRefreshToken","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","createBindingKeyNotRemovedError","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","getAccessToken","cachedRefreshToken","getRefreshToken","cachedAppMetadata","readAppMetadataFromCache","AccountEntity","generateAccountCacheKey","trace","idTokenFilter","idTokens","getIdTokensByFilter","numIdTokens","info","createMultipleMatchingTokensInCacheError","idTokenKeys","idTokenKeyMatchesFilter","getIdTokenCredential","inputKey","scopes","createSearchScopes","authScheme","authenticationScheme","BEARER","sshKid","accessTokenKeys","accessTokens","numAccessTokens","keyMustContainAllScopes","asArray","i","familyRT","id","undefined","refreshTokenFilter","refreshTokenKeys","refreshTokens","refreshTokenKeyMatchesFilter","getRefreshTokenCredential","numRefreshTokens","appMetadataFilter","getAppMetadataFilteredBy","appMetadataEntries","Object","keys","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","cloudMetadata","getAuthorityMetadataByAlias","isNotAccessTokenCredential","entityScopeSet","containsScopeSet","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","authority","obj","json","propertyName","__extends","DefaultStorageClass","notImplErr","AuthError","createUnexpectedError"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@azure\\msal-common\\src\\cache\\CacheManager.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountFilter, CredentialFilter, ValidCredentialType, AppMetadataFilter, AppMetadataCache, TokenKeys } from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport { CredentialType, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme, Separators } from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\r\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\r\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { name, version } from \"../packageMetadata\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n    protected clientId: string;\r\n    protected cryptoImpl: ICrypto;\r\n    // Instance of logger for functions defined in the msal-common layer\r\n    private commonLogger: Logger;\r\n\r\n    constructor(clientId: string, cryptoImpl: ICrypto, logger: Logger) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n        this.commonLogger = logger.clone(name, version);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     *  @param accountKey\r\n     */\r\n    abstract getAccount(accountKey: string): AccountEntity | null;\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    abstract setAccount(account: AccountEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param idTokenKey\r\n     */\r\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param idToken\r\n     */\r\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param accessTokenKey\r\n     */\r\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param accessToken\r\n     */\r\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param refreshTokenKey\r\n     */\r\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\r\n\r\n    /**\r\n     * fetch cloud discovery metadata entity from the platform cache\r\n     * @param key\r\n     */\r\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\r\n\r\n    /**\r\n     *\r\n     */\r\n    abstract getAuthorityMetadataKeys(): Array<string>;\r\n\r\n    /**\r\n     * set cloud discovery metadata entity to the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string): void;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all account keys from the cache\r\n     */\r\n    abstract getAccountKeys(): string[];\r\n\r\n    /**\r\n     * Function which retrieves all token keys from the cache\r\n     */\r\n    abstract getTokenKeys(): TokenKeys;\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): Promise<void>;\r\n\r\n    /**\r\n     * Function which updates an outdated credential cache key\r\n     */\r\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\r\n\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        if (allAccountKeys.length < 1) {\r\n            return [];\r\n        }\r\n\r\n        const accountEntities: AccountEntity[] = allAccountKeys.reduce((accounts: AccountEntity[], key: string) => {\r\n            const entity: AccountEntity | null = this.getAccount(key);\r\n\r\n            if (!entity) {\r\n                return accounts;\r\n            }\r\n            accounts.push(entity);\r\n            return accounts;\r\n        }, []);\r\n\r\n        if (accountEntities.length < 1) {\r\n            return [];\r\n        } else {\r\n            const allAccounts = accountEntities.map<AccountInfo>((accountEntity) => {\r\n                return this.getAccountInfoFromEntity(accountEntity);\r\n            });\r\n            return allAccounts;\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Gets accountInfo object based on provided filters\r\n     */\r\n    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null{\r\n        const allAccounts = this.getAccountsFilteredBy(accountFilter);\r\n        if (allAccounts.length > 0) {\r\n            return this.getAccountInfoFromEntity(allAccounts[0]);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private getAccountInfoFromEntity(accountEntity: AccountEntity): AccountInfo {\r\n        const accountInfo = accountEntity.getAccountInfo();\r\n        const idToken = this.getIdToken(accountInfo);\r\n        if (idToken) {\r\n            accountInfo.idToken = idToken.secret;\r\n            accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\r\n        }\r\n        return accountInfo;\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken) {\r\n            await this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\r\n        const accessTokenFilter: CredentialFilter = {\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n            tokenType: credential.tokenType,\r\n            requestedClaimsHash: credential.requestedClaimsHash\r\n        };\r\n\r\n        const tokenKeys = this.getTokenKeys();\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n\r\n        const removedAccessTokens: Array<Promise<void>> = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if(!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\r\n                return;\r\n            }\r\n            \r\n            const tokenEntity = this.getAccessTokenCredential(key);\r\n\r\n            if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    removedAccessTokens.push(this.removeAccessToken(key));\r\n                }\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n        this.setAccessTokenCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[] {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const matchingAccounts: AccountEntity[] = [];\r\n\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {\r\n                // Don't parse value if the key doesn't match the account filters\r\n                return;\r\n            }\r\n\r\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.localAccountId && !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.username && !this.matchUsername(entity, accountFilter.username)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\r\n                return;\r\n            }\r\n\r\n            if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAccounts.push(entity);\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\r\n     * @param key \r\n     * @param homeAccountId \r\n     * @param tenantId \r\n     * @returns \r\n     */\r\n    isAccountKey(key: string, homeAccountId?: string, tenantId?: string): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\r\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        // Do not check environment as aliasing can cause false negatives\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given key matches our credential key schema.\r\n     * @param key \r\n     */\r\n    isCredentialKey(key: string): boolean {\r\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\r\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\r\n            return false;\r\n        }\r\n\r\n        const lowerCaseKey = key.toLowerCase();\r\n        // Credential keys must indicate what credential type they represent\r\n        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&\r\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\r\n            // Refresh tokens must contain the client id or family id\r\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\r\n            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\r\n                return false;\r\n            }\r\n        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\r\n            // Tokens must contain the clientId\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the given credential entity matches the filter\r\n     * @param entity \r\n     * @param filter \r\n     * @returns \r\n     */\r\n    credentialMatchesFilter(entity: ValidCredentialType, filter: CredentialFilter): boolean {\r\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n         */\r\n        if ((typeof filter.homeAccountId === \"string\") && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\r\n            return false;\r\n        }\r\n\r\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n         */\r\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\r\n            return false;\r\n        }\r\n\r\n        // If request OR cached entity has requested Claims Hash, check if they match\r\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\r\n            // Don't match if either is undefined or they are different\r\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Access Token with Auth Scheme specific matching\r\n        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\r\n            if(!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\r\n                return false;\r\n            }\r\n\r\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n            if (filter.tokenType === AuthenticationScheme.SSH) {\r\n                if(filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\r\n        return this.getAppMetadataFilteredByInternal(\r\n            filter.environment,\r\n            filter.clientId,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    private getAppMetadataFilteredByInternal(\r\n        environment?: string,\r\n        clientId?: string\r\n    ): AppMetadataCache {\r\n\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata: AppMetadataCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAppMetadata[cacheKey] = entity;\r\n\r\n        });\r\n\r\n        return matchingAppMetadata;\r\n    }\r\n\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n\r\n            matchedEntity = entity;\r\n\r\n        });\r\n\r\n        return matchedEntity;\r\n    }\r\n\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    async removeAllAccounts(): Promise<void> {\r\n        const allAccountKeys = this.getAccountKeys();\r\n        const removedAccounts: Array<Promise<void>> = [];\r\n\r\n        allAccountKeys.forEach((cacheKey) => {\r\n            removedAccounts.push(this.removeAccount(cacheKey));\r\n        });\r\n\r\n        await Promise.all(removedAccounts);\r\n    }\r\n\r\n    /**\r\n     * Removes the account and related tokens for a given account key\r\n     * @param account\r\n     */\r\n    async removeAccount(accountKey: string): Promise<void> {\r\n        const account = this.getAccount(accountKey);\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        await this.removeAccountContext(account);\r\n        this.removeItem(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account: AccountEntity): Promise<void> {\r\n        const allTokenKeys = this.getTokenKeys();\r\n        const accountId = account.generateAccountId();\r\n        const removedCredentials: Array<Promise<void>> = [];\r\n\r\n        allTokenKeys.idToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeIdToken(key);\r\n            }\r\n        });\r\n\r\n        allTokenKeys.accessToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                removedCredentials.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n\r\n        allTokenKeys.refreshToken.forEach((key) => {\r\n            if (key.indexOf(accountId) === 0) {\r\n                this.removeRefreshToken(key);\r\n            }\r\n        });\r\n\r\n        await Promise.all(removedCredentials);\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    async removeAccessToken(key: string): Promise<void> {\r\n        const credential = this.getAccessTokenCredential(key);\r\n        if (!credential) {\r\n            return;\r\n        }\r\n\r\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\r\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\r\n            if(credential.tokenType === AuthenticationScheme.POP) {\r\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\r\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\r\n\r\n                if (kid) {\r\n                    try {\r\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\r\n                    } catch (error) {\r\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    readCacheRecord(account: AccountInfo, request: BaseAuthRequest, environment: string): CacheRecord {\r\n        const tokenKeys = this.getTokenKeys();\r\n        const cachedAccount = this.readAccountFromCache(account);\r\n        const cachedIdToken = this.getIdToken(account, tokenKeys);\r\n        const cachedAccessToken = this.getAccessToken(account, request, tokenKeys);\r\n        const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);\r\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment);\r\n\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\r\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    getIdToken(account: AccountInfo, tokenKeys?: TokenKeys): IdTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\r\n        const idTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.clientId,\r\n            realm: account.tenantId,\r\n        };\r\n\r\n        const idTokens: IdTokenEntity[] = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\r\n        const numIdTokens = idTokens.length;\r\n\r\n        if (numIdTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\r\n            return null;\r\n        } else if (numIdTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\r\n        return idTokens[0];\r\n    }\r\n\r\n    /**\r\n     * Gets all idTokens matching the given filter\r\n     * @param filter \r\n     * @returns \r\n     */\r\n    getIdTokensByFilter(filter: CredentialFilter, tokenKeys?: TokenKeys): IdTokenEntity[] {\r\n        const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\r\n\r\n        const idTokens: IdTokenEntity[] = [];\r\n        idTokenKeys.forEach((key) => {\r\n            if (!this.idTokenKeyMatchesFilter(key, {clientId: this.clientId, ...filter})) {\r\n                return;\r\n            }\r\n\r\n            const idToken = this.getIdTokenCredential(key);\r\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\r\n                idTokens.push(idToken);\r\n            }\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key \r\n     * @param filter\r\n     * @returns \r\n     */\r\n    idTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Removes idToken from the cache\r\n     * @param key \r\n     */\r\n    removeIdToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes refresh token from the cache\r\n     * @param key \r\n     */\r\n    removeRefreshToken(key: string): void {\r\n        this.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    getAccessToken(account: AccountInfo, request: BaseAuthRequest, tokenKeys?: TokenKeys): AccessTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\r\n        const scopes =  ScopeSet.createSearchScopes(request.scopes);\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: this.clientId,\r\n            realm: account.tenantId,\r\n            target: scopes,\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n\r\n        const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n\r\n        accessTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\r\n                const accessToken = this.getAccessTokenCredential(key);\r\n\r\n                // Validate value\r\n                if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\r\n                    accessTokens.push(accessToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\r\n            return null;\r\n        } else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\r\n        return accessTokens[0];\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key \r\n     * @param filter \r\n     * @param keyMustContainAllScopes \r\n     * @returns \r\n     */\r\n    accessTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter, keyMustContainAllScopes: boolean): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.target) {\r\n            const scopes = filter.target.asArray();\r\n            for (let i = 0; i < scopes.length; i++) {\r\n                if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache lookup a missing scope would be a cache miss\r\n                    return false;\r\n                } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\r\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets all access tokens matching the filter\r\n     * @param filter \r\n     * @returns \r\n     */\r\n    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[] {\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        const accessTokens: AccessTokenEntity[] = [];\r\n        tokenKeys.accessToken.forEach((key) => {\r\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\r\n                return;\r\n            }\r\n\r\n            const accessToken = this.getAccessTokenCredential(key);\r\n            if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\r\n                accessTokens.push(accessToken);\r\n            }\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    getRefreshToken(account: AccountInfo, familyRT: boolean, tokenKeys?: TokenKeys): RefreshTokenEntity | null {\r\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: this.clientId,\r\n            familyId: id,\r\n        };\r\n\r\n        const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\r\n        const refreshTokens: RefreshTokenEntity[] = [];\r\n\r\n        refreshTokenKeys.forEach((key) => {\r\n            // Validate key\r\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\r\n                const refreshToken = this.getRefreshTokenCredential(key);\r\n                // Validate value\r\n                if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\r\n                    refreshTokens.push(refreshToken);\r\n                }\r\n            }\r\n        });\r\n\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n\r\n        this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\r\n        return refreshTokens[0] as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Validate the cache key against filter before retrieving and parsing cache value\r\n     * @param key\r\n     * @param filter\r\n     */\r\n    refreshTokenKeyMatchesFilter(inputKey: string, filter: CredentialFilter): boolean {\r\n        const key = inputKey.toLowerCase();\r\n        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        // If familyId is used, clientId is not in the key\r\n        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\r\n        const appMetadataFilter: AppMetadataFilter = {\r\n            environment,\r\n            clientId: this.clientId,\r\n        };\r\n\r\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\r\n\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        } else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n\r\n        return appMetadataEntries[0] as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment: string): boolean {\r\n        const appMetadata = this.readAppMetadataFromCache(environment);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\r\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param entity \r\n     * @param localAccountId \r\n     * @returns \r\n     */\r\n    private matchLocalAccountId(entity: AccountEntity, localAccountId: string): boolean {\r\n        return !!((typeof entity.localAccountId === \"string\") && (localAccountId === entity.localAccountId));\r\n    }\r\n\r\n    /**\r\n     * helper to match usernames\r\n     * @param entity \r\n     * @param username \r\n     * @returns \r\n     */\r\n    private matchUsername(entity: AccountEntity, username: string): boolean {\r\n        return !!((typeof entity.username === \"string\") && (username.toLowerCase() === entity.username.toLowerCase()));\r\n    }\r\n\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    private matchUserAssertionHash(entity: CredentialEntity, userAssertionHash: string): boolean {\r\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\r\n    }\r\n\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    }\r\n\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    private matchNativeAccountId(entity: AccountEntity, nativeAccountId: string): boolean {\r\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\r\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n\r\n        if ( isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n\r\n        return entityScopeSet.containsScopeSet(target);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    protected isAuthorityMetadata(key: string): boolean {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority: string): string {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setAccount(): void {\r\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccount(): AccountEntity {\r\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setIdTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getIdTokenCredential(): IdTokenEntity {\r\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAccessTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccessTokenCredential(): AccessTokenEntity {\r\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setRefreshTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getRefreshTokenCredential(): RefreshTokenEntity {\r\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAppMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAppMetadata(): AppMetadataEntity {\r\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setServerTelemetry(): void {\r\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getServerTelemetry(): ServerTelemetryEntity {\r\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAuthorityMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setThrottlingCache(): void {\r\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getThrottlingCache(): ThrottlingEntity {\r\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    removeItem(): boolean {\r\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    containsKey(): boolean {\r\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccountKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getTokenKeys(): TokenKeys {\r\n        const notImplErr = \"Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    async clear(): Promise<void> {\r\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    updateCredentialCacheKey(): string {\r\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}