{"ast":null,"code":"import * as React from 'react';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport { elementContains } from '@fluentui/react-portal';\n/**\n * Name of the custom event\n */\n\nexport const MENU_ENTER_EVENT = 'fuimenuenter';\n/**\n * This hook works similarly to @see {useOnClickOutside}\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */\n\nexport const useOnMenuMouseEnter = options => {\n  const {\n    refs,\n    callback,\n    element,\n    disabled\n  } = options; // Keep mouse event here because this is essentially a custom 'mouseenter' event\n\n  const listener = useEventCallback(ev => {\n    var _a;\n    const popoverRef = refs[0];\n    const someMenuPopover = ev.target; // someMenu is a child -> will always be contained because of vParents\n    // someMenu is a parent -> will always not be contained because no vParent\n    // someMenu is the current popover -> it will contain itself\n\n    const isOutsidePopover = !elementContains((_a = popoverRef.current) !== null && _a !== void 0 ? _a : null, someMenuPopover);\n    if (isOutsidePopover && !disabled) {\n      callback(ev);\n    }\n  });\n  React.useEffect(() => {\n    // eslint-disable-next-line eqeqeq\n    if (element == null) {\n      return;\n    }\n    if (!disabled) {\n      element.addEventListener(MENU_ENTER_EVENT, listener);\n    }\n    return () => {\n      element.removeEventListener(MENU_ENTER_EVENT, listener);\n    };\n  }, [listener, element, disabled]);\n};\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el element for the event target\n * @param nativeEvent the native mouse event this is mapped to\n */\n\nexport const dispatchMenuEnterEvent = (el, nativeEvent) => {\n  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {\n    bubbles: true,\n    detail: {\n      nativeEvent\n    }\n  }));\n};","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,gBAAT,QAAiC,2BAAjC;AACA,SAASC,eAAT,QAAgC,wBAAhC;AAGA;;AAEG;;AACH,OAAO,MAAMC,gBAAgB,GAAG,cAAzB;AAEP;;;;;;;;;;AAUG;;AACH,OAAO,MAAMC,mBAAmB,GAAIC,OAAD,IAA8C;EAC/E,MAAM;IAAEC,IAAF;IAAQC,QAAR;IAAkBC,OAAlB;IAA2BC;EAA3B,IAAwCJ,OAA9C,CAD+E,CAG/E;;EACA,MAAMK,QAAQ,GAAGT,gBAAgB,CAAEU,EAAD,IAAmB;;IACnD,MAAMC,UAAU,GAAGN,IAAI,CAAC,CAAD,CAAvB;IACA,MAAMO,eAAe,GAAGF,EAAE,CAACG,MAA3B,CAFmD,CAInD;IACA;IACA;;IACA,MAAMC,gBAAgB,GAAG,CAACb,eAAe,CAAC,gBAAU,CAACc,OAAX,MAAkB,IAAlB,IAAkBC,aAAlB,GAAkBA,EAAlB,GAAsB,IAAvB,EAA6BJ,eAA7B,CAAzC;IACA,IAAIE,gBAAgB,IAAI,CAACN,QAAzB,EAAmC;MACjCF,QAAQ,CAACI,EAAD,CAAR;IACD;EACF,CAXgC,CAAjC;EAaAX,KAAK,CAACkB,SAAN,CAAgB,MAAK;IACnB;IACA,IAAIV,OAAO,IAAI,IAAf,EAAqB;MACnB;IACD;IAUD,IAAI,CAACC,QAAL,EAAe;MACbD,OAAO,CAACW,gBAAR,CAAyBhB,gBAAzB,EAA2CO,QAA3C;IACD;IAED,OAAO,MAAK;MACVF,OAAO,CAACY,mBAAR,CAA4BjB,gBAA5B,EAA8CO,QAA9C;IACD,CAFD;EAGD,CArBD,EAqBG,CAACA,QAAD,EAAWF,OAAX,EAAoBC,QAApB,CArBH;AAsBD,CAvCM;AAyCP;;;;AAIG;;AACH,OAAO,MAAMY,sBAAsB,GAAG,CAACC,EAAD,EAAkBC,WAAlB,KAA6C;EACjFD,EAAE,CAACE,aAAH,CAAiB,IAAIC,WAAJ,CAAgBtB,gBAAhB,EAAkC;IAAEuB,OAAO,EAAE,IAAX;IAAiBC,MAAM,EAAE;MAAEJ;IAAF;EAAzB,CAAlC,CAAjB;AACD,CAFM","names":["React","useEventCallback","elementContains","MENU_ENTER_EVENT","useOnMenuMouseEnter","options","refs","callback","element","disabled","listener","ev","popoverRef","someMenuPopover","target","isOutsidePopover","current","_a","useEffect","addEventListener","removeEventListener","dispatchMenuEnterEvent","el","nativeEvent","dispatchEvent","CustomEvent","bubbles","detail"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-menu\\lib\\src\\packages\\react-components\\react-menu\\src\\utils\\useOnMenuEnter.ts"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback } from '@fluentui/react-utilities';\nimport { elementContains } from '@fluentui/react-portal';\nimport type { UseOnClickOrScrollOutsideOptions } from '@fluentui/react-utilities';\n\n/**\n * Name of the custom event\n */\nexport const MENU_ENTER_EVENT = 'fuimenuenter';\n\n/**\n * This hook works similarly to @see {useOnClickOutside}\n *\n * Problem: Trying to behave the same as system menus:\n * When the mouse leaves a stack of nested menus the stack should not dismiss.\n * However if the mouse leaves a stack of menus and enters a parent menu all its children menu should dismiss.\n *\n * We don't use the native mouseenter event because it would trigger too many times in the document\n * Instead, dispatch custom DOM event from the menu so that it can bubble\n * Each nested menu can use the listener to check if the event is from a child or parent menu\n */\nexport const useOnMenuMouseEnter = (options: UseOnClickOrScrollOutsideOptions) => {\n  const { refs, callback, element, disabled } = options;\n\n  // Keep mouse event here because this is essentially a custom 'mouseenter' event\n  const listener = useEventCallback((ev: MouseEvent) => {\n    const popoverRef = refs[0];\n    const someMenuPopover = ev.target as HTMLElement;\n\n    // someMenu is a child -> will always be contained because of vParents\n    // someMenu is a parent -> will always not be contained because no vParent\n    // someMenu is the current popover -> it will contain itself\n    const isOutsidePopover = !elementContains(popoverRef.current ?? null, someMenuPopover);\n    if (isOutsidePopover && !disabled) {\n      callback(ev);\n    }\n  });\n\n  React.useEffect(() => {\n    // eslint-disable-next-line eqeqeq\n    if (element == null) {\n      return;\n    }\n\n    /**\n     * Because `addEventListener` type override falls back to 2nd definition (evt name is unknown string literal)\n     * evt is being typed as a base class of MouseEvent -> `Event`.\n     * This type is used to override `listener` calls to make TS happy\n     */\n\n    type ListenerOverride = (evt: Event) => void;\n\n    if (!disabled) {\n      element.addEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    }\n\n    return () => {\n      element.removeEventListener(MENU_ENTER_EVENT, listener as ListenerOverride);\n    };\n  }, [listener, element, disabled]);\n};\n\n/**\n * Dispatches the custom MouseEvent enter event. Similar to calling `el.click()`\n * @param el element for the event target\n * @param nativeEvent the native mouse event this is mapped to\n */\nexport const dispatchMenuEnterEvent = (el: HTMLElement, nativeEvent: MouseEvent) => {\n  el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, { bubbles: true, detail: { nativeEvent } }));\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}