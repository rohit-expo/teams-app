{"ast":null,"code":"import * as React from 'react';\nimport { useMergedRefs, useEventCallback, useControllableState, getNativeElementProps } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useHasParentContext } from '@fluentui/react-context-selector';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MenuContext } from '../../contexts/menuContext';\n/**\n * Returns the props and state required to render the component\n */\n\nexport const useMenuList_unstable = (props, ref) => {\n  const focusAttributes = useArrowNavigationGroup({\n    circular: true,\n    ignoreDefaultKeydown: {\n      Tab: true\n    }\n  });\n  const {\n    findAllFocusable\n  } = useFocusFinders();\n  const menuContext = useMenuContextSelectors();\n  const hasMenuContext = useHasParentContext(MenuContext);\n  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {\n    // TODO throw warnings in development safely\n    // eslint-disable-next-line no-console\n    console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');\n  }\n  const innerRef = React.useRef(null);\n  const setFocusByFirstCharacter = React.useCallback((e, itemEl) => {\n    // TODO use some kind of children registration to reduce dependency on DOM roles\n    const acceptedRoles = ['menuitem', 'menuitemcheckbox', 'menuitemradio'];\n    if (!innerRef.current) {\n      return;\n    }\n    const menuItems = findAllFocusable(innerRef.current, el => el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')) !== -1);\n    let startIndex = menuItems.indexOf(itemEl) + 1;\n    if (startIndex === menuItems.length) {\n      startIndex = 0;\n    }\n    const firstChars = menuItems.map(menuItem => {\n      var _a;\n      return (_a = menuItem.textContent) === null || _a === void 0 ? void 0 : _a.charAt(0).toLowerCase();\n    });\n    const char = e.key.toLowerCase();\n    const getIndexFirstChars = (start, firstChar) => {\n      for (let i = start; i < firstChars.length; i++) {\n        if (char === firstChars[i]) {\n          return i;\n        }\n      }\n      return -1;\n    }; // Check remaining slots in the menu\n\n    let index = getIndexFirstChars(startIndex, char); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = getIndexFirstChars(0, char);\n    } // If match was found...\n\n    if (index > -1) {\n      menuItems[index].focus();\n    }\n  }, [findAllFocusable]);\n  const [checkedValues, setCheckedValues] = useControllableState({\n    state: hasMenuContext ? menuContext.checkedValues : props.checkedValues,\n    defaultState: props.defaultCheckedValues,\n    initialState: {}\n  });\n  const handleCheckedValueChange = hasMenuContext ? menuContext.onCheckedValueChange : props.onCheckedValueChange;\n  const toggleCheckbox = useEventCallback((e, name, value, checked) => {\n    const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name]) || [];\n    const newCheckedItems = [...checkedItems];\n    if (checked) {\n      newCheckedItems.splice(newCheckedItems.indexOf(value), 1);\n    } else {\n      newCheckedItems.push(value);\n    }\n    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n      name,\n      checkedItems: newCheckedItems\n    });\n    setCheckedValues(s => ({\n      ...s,\n      [name]: newCheckedItems\n    }));\n  });\n  const selectRadio = useEventCallback((e, name, value) => {\n    const newCheckedItems = [value];\n    setCheckedValues(s => ({\n      ...s,\n      [name]: newCheckedItems\n    }));\n    handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e, {\n      name,\n      checkedItems: newCheckedItems\n    });\n  });\n  return {\n    components: {\n      root: 'div'\n    },\n    root: getNativeElementProps('div', {\n      ref: useMergedRefs(ref, innerRef),\n      role: 'menu',\n      'aria-labelledby': menuContext.triggerId,\n      ...focusAttributes,\n      ...props\n    }),\n    hasIcons: menuContext.hasIcons || false,\n    hasCheckmarks: menuContext.hasCheckmarks || false,\n    checkedValues,\n    setFocusByFirstCharacter,\n    selectRadio,\n    toggleCheckbox\n  };\n};\n/**\n * Adds some sugar to fetching multiple context selector values\n */\n\nconst useMenuContextSelectors = () => {\n  const checkedValues = useMenuContext_unstable(context => context.checkedValues);\n  const onCheckedValueChange = useMenuContext_unstable(context => context.onCheckedValueChange);\n  const triggerId = useMenuContext_unstable(context => context.triggerId);\n  const hasIcons = useMenuContext_unstable(context => context.hasIcons);\n  const hasCheckmarks = useMenuContext_unstable(context => context.hasCheckmarks);\n  return {\n    checkedValues,\n    onCheckedValueChange,\n    triggerId,\n    hasIcons,\n    hasCheckmarks\n  };\n};\n/**\n * Helper function to detect if props and MenuContext values are both used\n */\n\nconst usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {\n  let isUsingPropsAndContext = false;\n  for (const val in contextValue) {\n    if (props[val]) {\n      isUsingPropsAndContext = true;\n    }\n  }\n  return hasMenuContext && isUsingPropsAndContext;\n};","map":{"version":3,"mappings":"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","names":["React","useMergedRefs","useEventCallback","useControllableState","getNativeElementProps","useArrowNavigationGroup","useFocusFinders","useHasParentContext","useMenuContext_unstable","MenuContext","useMenuList_unstable","props","ref","focusAttributes","circular","ignoreDefaultKeydown","Tab","findAllFocusable","menuContext","useMenuContextSelectors","hasMenuContext","usingPropsAndMenuContext","console","warn","innerRef","useRef","setFocusByFirstCharacter","useCallback","e","itemEl","acceptedRoles","current","menuItems","el","hasAttribute","indexOf","getAttribute","startIndex","length","firstChars","map","menuItem","textContent","_a","charAt","toLowerCase","char","key","getIndexFirstChars","start","firstChar","i","index","focus","checkedValues","setCheckedValues","state","defaultState","defaultCheckedValues","initialState","handleCheckedValueChange","onCheckedValueChange","toggleCheckbox","name","value","checked","checkedItems","newCheckedItems","splice","push","s","selectRadio","components","root","role","triggerId","hasIcons","hasCheckmarks","context","contextValue","isUsingPropsAndContext","val"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-menu\\lib\\components\\src\\packages\\react-components\\react-menu\\src\\components\\MenuList\\useMenuList.ts"],"sourcesContent":["import * as React from 'react';\nimport {\n  useMergedRefs,\n  useEventCallback,\n  useControllableState,\n  getNativeElementProps,\n} from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useHasParentContext } from '@fluentui/react-context-selector';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { MenuContext } from '../../contexts/menuContext';\nimport type { MenuListProps, MenuListState } from './MenuList.types';\n\n/**\n * Returns the props and state required to render the component\n */\nexport const useMenuList_unstable = (props: MenuListProps, ref: React.Ref<HTMLElement>): MenuListState => {\n  const focusAttributes = useArrowNavigationGroup({ circular: true, ignoreDefaultKeydown: { Tab: true } });\n  const { findAllFocusable } = useFocusFinders();\n  const menuContext = useMenuContextSelectors();\n  const hasMenuContext = useHasParentContext(MenuContext);\n\n  if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {\n    // TODO throw warnings in development safely\n    // eslint-disable-next-line no-console\n    console.warn('You are using both MenuList and Menu props, we recommend you to use Menu props when available');\n  }\n\n  const innerRef = React.useRef<HTMLElement>(null);\n\n  const setFocusByFirstCharacter = React.useCallback(\n    (e: React.KeyboardEvent<HTMLElement>, itemEl: HTMLElement) => {\n      // TODO use some kind of children registration to reduce dependency on DOM roles\n      const acceptedRoles = ['menuitem', 'menuitemcheckbox', 'menuitemradio'];\n      if (!innerRef.current) {\n        return;\n      }\n\n      const menuItems = findAllFocusable(\n        innerRef.current,\n        (el: HTMLElement) => el.hasAttribute('role') && acceptedRoles.indexOf(el.getAttribute('role')!) !== -1,\n      );\n\n      let startIndex = menuItems.indexOf(itemEl) + 1;\n      if (startIndex === menuItems.length) {\n        startIndex = 0;\n      }\n\n      const firstChars = menuItems.map(menuItem => menuItem.textContent?.charAt(0).toLowerCase());\n      const char = e.key.toLowerCase();\n\n      const getIndexFirstChars = (start: number, firstChar: string) => {\n        for (let i = start; i < firstChars.length; i++) {\n          if (char === firstChars[i]) {\n            return i;\n          }\n        }\n        return -1;\n      };\n\n      // Check remaining slots in the menu\n      let index = getIndexFirstChars(startIndex, char);\n\n      // If not found in remaining slots, check from beginning\n      if (index === -1) {\n        index = getIndexFirstChars(0, char);\n      }\n\n      // If match was found...\n      if (index > -1) {\n        menuItems[index].focus();\n      }\n    },\n    [findAllFocusable],\n  );\n\n  const [checkedValues, setCheckedValues] = useControllableState({\n    state: hasMenuContext ? menuContext.checkedValues : props.checkedValues,\n    defaultState: props.defaultCheckedValues,\n    initialState: {},\n  });\n\n  const handleCheckedValueChange = hasMenuContext ? menuContext.onCheckedValueChange : props.onCheckedValueChange;\n\n  const toggleCheckbox = useEventCallback(\n    (e: React.MouseEvent | React.KeyboardEvent, name: string, value: string, checked: boolean) => {\n      const checkedItems = checkedValues?.[name] || [];\n      const newCheckedItems = [...checkedItems];\n      if (checked) {\n        newCheckedItems.splice(newCheckedItems.indexOf(value), 1);\n      } else {\n        newCheckedItems.push(value);\n      }\n\n      handleCheckedValueChange?.(e, { name, checkedItems: newCheckedItems });\n      setCheckedValues(s => ({ ...s, [name]: newCheckedItems }));\n    },\n  );\n\n  const selectRadio = useEventCallback((e: React.MouseEvent | React.KeyboardEvent, name: string, value: string) => {\n    const newCheckedItems = [value];\n    setCheckedValues(s => ({ ...s, [name]: newCheckedItems }));\n    handleCheckedValueChange?.(e, { name, checkedItems: newCheckedItems });\n  });\n\n  return {\n    components: {\n      root: 'div',\n    },\n    root: getNativeElementProps('div', {\n      ref: useMergedRefs(ref, innerRef),\n      role: 'menu',\n      'aria-labelledby': menuContext.triggerId,\n      ...focusAttributes,\n      ...props,\n    }),\n    hasIcons: menuContext.hasIcons || false,\n    hasCheckmarks: menuContext.hasCheckmarks || false,\n    checkedValues,\n    setFocusByFirstCharacter,\n    selectRadio,\n    toggleCheckbox,\n  };\n};\n\n/**\n * Adds some sugar to fetching multiple context selector values\n */\nconst useMenuContextSelectors = () => {\n  const checkedValues = useMenuContext_unstable(context => context.checkedValues);\n  const onCheckedValueChange = useMenuContext_unstable(context => context.onCheckedValueChange);\n  const triggerId = useMenuContext_unstable(context => context.triggerId);\n  const hasIcons = useMenuContext_unstable(context => context.hasIcons);\n  const hasCheckmarks = useMenuContext_unstable(context => context.hasCheckmarks);\n\n  return {\n    checkedValues,\n    onCheckedValueChange,\n    triggerId,\n    hasIcons,\n    hasCheckmarks,\n  };\n};\n\n/**\n * Helper function to detect if props and MenuContext values are both used\n */\nconst usingPropsAndMenuContext = (\n  props: MenuListProps,\n  contextValue: ReturnType<typeof useMenuContextSelectors>,\n  hasMenuContext: boolean,\n) => {\n  let isUsingPropsAndContext = false;\n  for (const val in contextValue) {\n    if (props[val as keyof Omit<typeof contextValue, 'hasMenuContext' | 'onCheckedValueChange' | 'triggerId'>]) {\n      isUsingPropsAndContext = true;\n    }\n  }\n\n  return hasMenuContext && isUsingPropsAndContext;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}