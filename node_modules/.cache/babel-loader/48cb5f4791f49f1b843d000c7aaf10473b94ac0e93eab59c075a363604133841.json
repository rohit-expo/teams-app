{"ast":null,"code":"import * as React from 'react';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { useIsSubmenu } from '../../utils/useIsSubmenu';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { ArrowRight, ArrowLeft, Escape, ArrowDown } from '@fluentui/keyboard-keys';\nimport { applyTriggerPropsToChildren, getTriggerChild, mergeCallbacks, useEventCallback, useMergedRefs } from '@fluentui/react-utilities';\nimport { useARIAButtonProps } from '@fluentui/react-aria';\n/**\n * Create the state required to render MenuTrigger.\n * Clones the only child component and adds necessary event handling behaviours to open a popup menu\n *\n * @param props - props from this instance of MenuTrigger\n */\n\nexport const useMenuTrigger_unstable = props => {\n  const {\n    children,\n    disableButtonEnhancement = false\n  } = props;\n  const triggerRef = useMenuContext_unstable(context => context.triggerRef);\n  const menuPopoverRef = useMenuContext_unstable(context => context.menuPopoverRef);\n  const setOpen = useMenuContext_unstable(context => context.setOpen);\n  const open = useMenuContext_unstable(context => context.open);\n  const triggerId = useMenuContext_unstable(context => context.triggerId);\n  const openOnHover = useMenuContext_unstable(context => context.openOnHover);\n  const openOnContext = useMenuContext_unstable(context => context.openOnContext);\n  const isSubmenu = useIsSubmenu();\n  const {\n    findFirstFocusable\n  } = useFocusFinders();\n  const focusFirst = React.useCallback(() => {\n    const firstFocusable = findFirstFocusable(menuPopoverRef.current);\n    firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();\n  }, [findFirstFocusable, menuPopoverRef]);\n  const openedWithKeyboardRef = React.useRef(false);\n  const hasMouseMoved = React.useRef(false);\n  const {\n    dir\n  } = useFluent();\n  const OpenArrowKey = dir === 'ltr' ? ArrowRight : ArrowLeft;\n  const child = getTriggerChild(children);\n  const onContextMenu = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnContext) {\n      event.preventDefault();\n      setOpen(event, {\n        open: true,\n        keyboard: false,\n        type: 'menuTriggerContextMenu',\n        event\n      });\n    }\n  };\n  const onClick = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (!openOnContext) {\n      setOpen(event, {\n        open: !open,\n        keyboard: openedWithKeyboardRef.current,\n        type: 'menuTriggerClick',\n        event\n      });\n      openedWithKeyboardRef.current = false;\n    }\n  };\n  const onKeyDown = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    const key = event.key;\n    if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === ArrowDown)) {\n      setOpen(event, {\n        open: true,\n        keyboard: true,\n        type: 'menuTriggerKeyDown',\n        event\n      });\n    }\n    if (key === Escape && !isSubmenu) {\n      setOpen(event, {\n        open: false,\n        keyboard: true,\n        type: 'menuTriggerKeyDown',\n        event\n      });\n    } // if menu is already open, can't rely on effects to focus\n\n    if (open && key === OpenArrowKey && isSubmenu) {\n      focusFirst();\n    }\n  };\n  const onMouseEnter = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover && hasMouseMoved.current) {\n      setOpen(event, {\n        open: true,\n        keyboard: false,\n        type: 'menuTriggerMouseEnter',\n        event\n      });\n    }\n  }; // Opening a menu when a mouse hasn't moved and just entering the trigger is a bad a11y experience\n  // First time open the mouse using mousemove and then continue with mouseenter\n  // Only use once to determine that the user is using the mouse since it is an expensive event to handle\n\n  const onMouseMove = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover && !hasMouseMoved.current) {\n      setOpen(event, {\n        open: true,\n        keyboard: false,\n        type: 'menuTriggerMouseMove',\n        event\n      });\n      hasMouseMoved.current = true;\n    }\n  };\n  const onMouseLeave = event => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover) {\n      setOpen(event, {\n        open: false,\n        keyboard: false,\n        type: 'menuTriggerMouseLeave',\n        event\n      });\n    }\n  };\n  const contextMenuProps = {\n    id: triggerId,\n    ...(child === null || child === void 0 ? void 0 : child.props),\n    ref: useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref),\n    onMouseEnter: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),\n    onMouseLeave: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),\n    onContextMenu: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),\n    onMouseMove: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove))\n  };\n  const triggerChildProps = {\n    'aria-haspopup': 'menu',\n    'aria-expanded': !open && !isSubmenu ? undefined : open,\n    ...contextMenuProps,\n    onClick: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),\n    onKeyDown: useEventCallback(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))\n  };\n  const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === 'button' || (child === null || child === void 0 ? void 0 : child.type) === 'a' ? child.type : 'div', triggerChildProps);\n  return {\n    isSubmenu,\n    children: applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)\n  };\n};\nconst isTargetDisabled = e => {\n  const isDisabled = el => el.hasAttribute('disabled') || el.hasAttribute('aria-disabled') && el.getAttribute('aria-disabled') === 'true';\n  if (e.target instanceof HTMLElement && isDisabled(e.target)) {\n    return true;\n  }\n  return e.currentTarget instanceof HTMLElement && isDisabled(e.currentTarget);\n};","map":{"version":3,"mappings":"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","names":["React","useMenuContext_unstable","useIsSubmenu","useFocusFinders","useFluent_unstable","useFluent","ArrowRight","ArrowLeft","Escape","ArrowDown","applyTriggerPropsToChildren","getTriggerChild","mergeCallbacks","useEventCallback","useMergedRefs","useARIAButtonProps","useMenuTrigger_unstable","props","children","disableButtonEnhancement","triggerRef","context","menuPopoverRef","setOpen","open","triggerId","openOnHover","openOnContext","isSubmenu","findFirstFocusable","focusFirst","useCallback","firstFocusable","current","focus","openedWithKeyboardRef","useRef","hasMouseMoved","dir","OpenArrowKey","child","onContextMenu","event","isTargetDisabled","preventDefault","keyboard","type","onClick","onKeyDown","key","onMouseEnter","onMouseMove","onMouseLeave","contextMenuProps","id","ref","triggerChildProps","undefined","ariaButtonTriggerChildProps","e","isDisabled","el","hasAttribute","getAttribute","target","HTMLElement","currentTarget"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-menu\\lib\\components\\src\\packages\\react-components\\react-menu\\src\\components\\MenuTrigger\\useMenuTrigger.ts"],"sourcesContent":["import * as React from 'react';\nimport { MenuTriggerProps, MenuTriggerState } from './MenuTrigger.types';\nimport { useMenuContext_unstable } from '../../contexts/menuContext';\nimport { useIsSubmenu } from '../../utils/useIsSubmenu';\nimport { useFocusFinders } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { ArrowRight, ArrowLeft, Escape, ArrowDown } from '@fluentui/keyboard-keys';\nimport {\n  applyTriggerPropsToChildren,\n  getTriggerChild,\n  mergeCallbacks,\n  useEventCallback,\n  useMergedRefs,\n} from '@fluentui/react-utilities';\nimport { useARIAButtonProps } from '@fluentui/react-aria';\n\n/**\n * Create the state required to render MenuTrigger.\n * Clones the only child component and adds necessary event handling behaviours to open a popup menu\n *\n * @param props - props from this instance of MenuTrigger\n */\nexport const useMenuTrigger_unstable = (props: MenuTriggerProps): MenuTriggerState => {\n  const { children, disableButtonEnhancement = false } = props;\n\n  const triggerRef = useMenuContext_unstable(context => context.triggerRef);\n  const menuPopoverRef = useMenuContext_unstable(context => context.menuPopoverRef);\n  const setOpen = useMenuContext_unstable(context => context.setOpen);\n  const open = useMenuContext_unstable(context => context.open);\n  const triggerId = useMenuContext_unstable(context => context.triggerId);\n  const openOnHover = useMenuContext_unstable(context => context.openOnHover);\n  const openOnContext = useMenuContext_unstable(context => context.openOnContext);\n\n  const isSubmenu = useIsSubmenu();\n\n  const { findFirstFocusable } = useFocusFinders();\n  const focusFirst = React.useCallback(() => {\n    const firstFocusable = findFirstFocusable(menuPopoverRef.current);\n    firstFocusable?.focus();\n  }, [findFirstFocusable, menuPopoverRef]);\n\n  const openedWithKeyboardRef = React.useRef(false);\n  const hasMouseMoved = React.useRef(false);\n\n  const { dir } = useFluent();\n  const OpenArrowKey = dir === 'ltr' ? ArrowRight : ArrowLeft;\n\n  const child = getTriggerChild(children);\n\n  const onContextMenu = (event: React.MouseEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n\n    if (openOnContext) {\n      event.preventDefault();\n      setOpen(event, { open: true, keyboard: false, type: 'menuTriggerContextMenu', event });\n    }\n  };\n\n  const onClick = (event: React.MouseEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n\n    if (!openOnContext) {\n      setOpen(event, { open: !open, keyboard: openedWithKeyboardRef.current, type: 'menuTriggerClick', event });\n      openedWithKeyboardRef.current = false;\n    }\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n\n    const key = event.key;\n\n    if (!openOnContext && ((isSubmenu && key === OpenArrowKey) || (!isSubmenu && key === ArrowDown))) {\n      setOpen(event, { open: true, keyboard: true, type: 'menuTriggerKeyDown', event });\n    }\n\n    if (key === Escape && !isSubmenu) {\n      setOpen(event, { open: false, keyboard: true, type: 'menuTriggerKeyDown', event });\n    }\n\n    // if menu is already open, can't rely on effects to focus\n    if (open && key === OpenArrowKey && isSubmenu) {\n      focusFirst();\n    }\n  };\n\n  const onMouseEnter = (event: React.MouseEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover && hasMouseMoved.current) {\n      setOpen(event, { open: true, keyboard: false, type: 'menuTriggerMouseEnter', event });\n    }\n  };\n\n  // Opening a menu when a mouse hasn't moved and just entering the trigger is a bad a11y experience\n  // First time open the mouse using mousemove and then continue with mouseenter\n  // Only use once to determine that the user is using the mouse since it is an expensive event to handle\n  const onMouseMove = (event: React.MouseEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover && !hasMouseMoved.current) {\n      setOpen(event, { open: true, keyboard: false, type: 'menuTriggerMouseMove', event });\n      hasMouseMoved.current = true;\n    }\n  };\n\n  const onMouseLeave = (event: React.MouseEvent<HTMLButtonElement & HTMLAnchorElement & HTMLDivElement>) => {\n    if (isTargetDisabled(event)) {\n      return;\n    }\n    if (openOnHover) {\n      setOpen(event, { open: false, keyboard: false, type: 'menuTriggerMouseLeave', event });\n    }\n  };\n\n  const contextMenuProps = {\n    id: triggerId,\n    ...child?.props,\n    ref: useMergedRefs(triggerRef, child?.ref),\n    onMouseEnter: useEventCallback(mergeCallbacks(child?.props.onMouseEnter, onMouseEnter)),\n    onMouseLeave: useEventCallback(mergeCallbacks(child?.props.onMouseLeave, onMouseLeave)),\n    onContextMenu: useEventCallback(mergeCallbacks(child?.props.onContextMenu, onContextMenu)),\n    onMouseMove: useEventCallback(mergeCallbacks(child?.props.onMouseMove, onMouseMove)),\n  };\n\n  const triggerChildProps = {\n    'aria-haspopup': 'menu',\n    'aria-expanded': !open && !isSubmenu ? undefined : open,\n    ...contextMenuProps,\n    onClick: useEventCallback(mergeCallbacks(child?.props.onClick, onClick)),\n    onKeyDown: useEventCallback(mergeCallbacks(child?.props.onKeyDown, onKeyDown)),\n  } as const;\n\n  const ariaButtonTriggerChildProps = useARIAButtonProps(\n    child?.type === 'button' || child?.type === 'a' ? child.type : 'div',\n    triggerChildProps,\n  );\n\n  return {\n    isSubmenu,\n    children: applyTriggerPropsToChildren(\n      children,\n      openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps,\n    ),\n  };\n};\n\nconst isTargetDisabled = (e: React.SyntheticEvent | Event) => {\n  const isDisabled = (el: HTMLElement) =>\n    el.hasAttribute('disabled') || (el.hasAttribute('aria-disabled') && el.getAttribute('aria-disabled') === 'true');\n  if (e.target instanceof HTMLElement && isDisabled(e.target)) {\n    return true;\n  }\n\n  return e.currentTarget instanceof HTMLElement && isDisabled(e.currentTarget);\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}