{"ast":null,"code":"function getDirectionalClassName(classes, direction) {\n  return Array.isArray(classes) ? direction === 'rtl' ? classes[1] : classes[0] : classes;\n}\nfunction getDebugClassNames(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {\n  const classesMapping = lookupItem[0];\n  const direction = lookupItem[1];\n  return Object.entries(classesMapping).map(_ref => {\n    let [propertyHash, classes] = _ref;\n    const className = getDirectionalClassName(classes, direction);\n    let overriddenBy;\n    if (parentDebugClassNames && parentLookupItem) {\n      const matching = parentDebugClassNames.find(_ref2 => {\n        let {\n          className: parentClassName\n        } = _ref2;\n        return parentClassName === className;\n      });\n      if (!matching && parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), but has current selector:\n        // style is overriden in current merging by another rule in sibling node\n        overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);\n      } else if (matching && parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), and has current selector:\n        // case 1. style is not overriden during current merging; it may be overriden in higher level of merging\n        // case 2. style is overriden in current merging by exactly the same rule in sibling nodes\n        const siblingHasSameRule = overridingSiblings ? overridingSiblings.filter(_ref3 => {\n          let {\n            debugClassNames\n          } = _ref3;\n          return debugClassNames.filter(_ref4 => {\n            let {\n              className: siblingClassName\n            } = _ref4;\n            return siblingClassName === className;\n          }).length > 0;\n        }).length > 0 : false;\n        overriddenBy = siblingHasSameRule ? matching.className // case 2\n        : matching.overriddenBy; // case 1\n      } else if (!matching && !parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), and does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      } else if (matching && !parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), but does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      }\n    }\n    return {\n      className,\n      overriddenBy\n    };\n  });\n}\nexport { getDebugClassNames };","map":{"version":3,"mappings":"AAGA,SAASA,uBAAuB,CAACC,OAAmB,EAAEC,SAAwB;EAC5E,OAAOC,KAAK,CAACC,OAAO,CAACH,OAAO,CAAC,GAAIC,SAAS,KAAK,KAAK,GAAGD,OAAO,CAAC,CAAC,CAAC,GAAGA,OAAO,CAAC,CAAC,CAAC,GAAIA,OAAO;AAC3F;SAEgBI,kBAAkB,CAChCC,UAAsB,EACtBC,gBAA6B,EAC7BC,qBAA8C,EAC9CC,kBAAoC;EAEpC,MAAMC,cAAc,GAAGJ,UAAU,CAAC,CAAC,CAAC;EACpC,MAAMJ,SAAS,GAAGI,UAAU,CAAC,CAAC,CAAC;EAE/B,OAAOK,MAAM,CAACC,OAAO,CAACF,cAAc,CAAC,CAACG,GAAG,CAAC,QAAwB;IAAA,IAAvB,CAACC,YAAY,EAAEb,OAAO,CAAC;IAChE,MAAMc,SAAS,GAAGf,uBAAuB,CAACC,OAAO,EAAEC,SAAS,CAAC;IAE7D,IAAIc,YAAgC;IACpC,IAAIR,qBAAqB,IAAID,gBAAgB,EAAE;MAC7C,MAAMU,QAAQ,GAAGT,qBAAqB,CAACU,IAAI,CAAC;QAAA,IAAC;UAAEH,SAAS,EAAEI;SAAiB;QAAA,OAAKA,eAAe,KAAKJ,SAAS;MAAA,EAAC;MAE9G,IAAI,CAACE,QAAQ,IAAIV,gBAAgB,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,EAAE;;;QAGlDE,YAAY,GAAGhB,uBAAuB,CAACO,gBAAgB,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,EAAEP,gBAAgB,CAAC,CAAC,CAAC,CAAC;OAC/F,MAAM,IAAIU,QAAQ,IAAIV,gBAAgB,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,EAAE;;;;QAIxD,MAAMM,kBAAkB,GAAGX,kBAAkB,GACzCA,kBAAkB,CAACY,MAAM,CACvB;UAAA,IAAC;YAAEC;WAAiB;UAAA,OAClBA,eAAe,CAACD,MAAM,CAAC;YAAA,IAAC;cAAEN,SAAS,EAAEQ;aAAkB;YAAA,OAAKA,gBAAgB,KAAKR,SAAS;UAAA,EAAC,CAACS,MAAM,GAAG,CAAC;QAAA,EACzG,CAACA,MAAM,GAAG,CAAC,GACZ,KAAK;QACTR,YAAY,GAAGI,kBAAkB,GAC7BH,QAAQ,CAACF,SAAS;QAAA,EAClBE,QAAQ,CAACD,YAAY,CAAC;OAC3B,MAAM,IAAI,CAACC,QAAQ,IAAI,CAACV,gBAAgB,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,EAAE;;;QAG1DE,YAAY,GAAGS,SAAS;OACzB,MAAM,IAAIR,QAAQ,IAAI,CAACV,gBAAgB,CAAC,CAAC,CAAC,CAACO,YAAY,CAAC,EAAE;;;QAGzDE,YAAY,GAAGS,SAAS;;;IAI5B,OAAO;MACLV,SAAS;MACTC;KACD;GACF,CAAC;AACJ","names":["getDirectionalClassName","classes","direction","Array","isArray","getDebugClassNames","lookupItem","parentLookupItem","parentDebugClassNames","overridingSiblings","classesMapping","Object","entries","map","propertyHash","className","overriddenBy","matching","find","parentClassName","siblingHasSameRule","filter","debugClassNames","siblingClassName","length","undefined"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\packages\\core\\src\\devtools\\utils.ts"],"sourcesContent":["import { CSSClasses, LookupItem } from '../types';\nimport { DebugAtomicClassName, DebugSequence } from './types';\n\nfunction getDirectionalClassName(classes: CSSClasses, direction: 'ltr' | 'rtl'): string {\n  return Array.isArray(classes) ? (direction === 'rtl' ? classes[1] : classes[0]) : classes;\n}\n\nexport function getDebugClassNames(\n  lookupItem: LookupItem,\n  parentLookupItem?: LookupItem,\n  parentDebugClassNames?: DebugAtomicClassName[],\n  overridingSiblings?: DebugSequence[],\n): DebugAtomicClassName[] {\n  const classesMapping = lookupItem[0];\n  const direction = lookupItem[1];\n\n  return Object.entries(classesMapping).map(([propertyHash, classes]) => {\n    const className = getDirectionalClassName(classes, direction);\n\n    let overriddenBy: string | undefined;\n    if (parentDebugClassNames && parentLookupItem) {\n      const matching = parentDebugClassNames.find(({ className: parentClassName }) => parentClassName === className);\n\n      if (!matching && parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), but has current selector:\n        // style is overriden in current merging by another rule in sibling node\n        overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);\n      } else if (matching && parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), and has current selector:\n        // case 1. style is not overriden during current merging; it may be overriden in higher level of merging\n        // case 2. style is overriden in current merging by exactly the same rule in sibling nodes\n        const siblingHasSameRule = overridingSiblings\n          ? overridingSiblings.filter(\n              ({ debugClassNames }) =>\n                debugClassNames.filter(({ className: siblingClassName }) => siblingClassName === className).length > 0,\n            ).length > 0\n          : false;\n        overriddenBy = siblingHasSameRule\n          ? matching.className // case 2\n          : matching.overriddenBy; // case 1\n      } else if (!matching && !parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), and does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      } else if (matching && !parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), but does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      }\n    }\n\n    return {\n      className,\n      overriddenBy,\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}