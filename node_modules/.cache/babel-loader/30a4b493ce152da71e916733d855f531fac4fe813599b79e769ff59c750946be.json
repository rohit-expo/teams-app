{"ast":null,"code":"/*! @azure/msal-common v13.2.0 2023-07-05 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Class that handles response parsing.\r\n */\nvar ResponseHandler = /** @class */function () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    }\n    // Check for error\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\n              // token nonce check (TODO: Add a warning if no nonce is given?)\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              }\n              // token max_age check\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            }\n            // generate homeAccountId\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            }\n            // Add keyId from request to serverTokenResponse if defined\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 5, 8]);\n            if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\n          case 2:\n            _b.sent();\n            _b.label = 3;\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n            return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\n          case 4:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\n          case 6:\n            _b.sent();\n            _b.label = 7;\n          case 7:\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    // IdToken: non AAD scenarios can have empty realm\n    var cachedIdToken;\n    var cachedAccount;\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\n    }\n    // AccessToken\n    var cachedAccessToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    var cachedRefreshToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    var cachedAppMetadata = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\n    // ADFS does not require client_info in the response\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    }\n    // This fallback applies to B2C as well as they fall under an AAD account type.\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3 /*break*/, 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n            return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\n          case 1:\n            accessToken = _e.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\n            // for hybrid + native bridge enablement, send back the native account Id\n            if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\n              cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n            }\n            return [2 /*return*/, {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n  return ResponseHandler;\n}();\nexport { ResponseHandler };","map":{"version":3,"mappings":"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","names":["clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","ResponseHandler","serverResponseHash","cachedState","state","ClientAuthError","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","InteractionRequiredAuthError","isInteractionRequiredError","Constants","EMPTY_STRING","timestamp","trace_id","correlation_id","claims","ServerError","client_info","buildClientInfo","serverResponse","errString","error_codes","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","addQueueMeasurement","PerformanceEvents","HandleServerTokenResponse","id_token","idTokenObj","AuthToken","StringUtils","isEmpty","nonce","createNonceMismatchError","maxAge","authTime","auth_time","createAuthTimeNotFoundError","checkMaxAge","homeAccountIdentifier","AccountEntity","generateHomeAccountId","authorityType","requestStateObj","ProtocolUtils","parseRequestState","key_id","sshKid","undefined","cacheRecord","generateCacheRecord","verbose","cacheContext","TokenCacheContext","beforeCacheAccess","_b","account","key","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","IdTokenEntity","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","ScopeSet","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","AccessTokenEntity","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","RefreshTokenEntity","createRefreshTokenEntity","foci","cachedAppMetadata","AppMetadataEntity","createAppMetadataEntity","CacheRecord","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","AuthorityType","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","requestId","accessToken","expiresOn","familyId","tokenType","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","_d","secret","keyId","createKeyIdMissingError","signPopToken","_e","target","asArray","Date","Number","extExpiresOn","extendedExpiresOn","appMetadata","THE_FAMILY_ID","uid","oid","sub","spa_accountid","nativeAccountId","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","correlationId","userRequestState","msGraphHost","code","spa_code","fromNativeBroker"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@azure\\msal-common\\src\\response\\ResponseHandler.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\r\nimport { buildClientInfo} from \"../account/ClientInfo\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\r\nimport { Logger } from \"../logger/Logger\";\r\nimport { ServerError } from \"../error/ServerError\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthenticationResult } from \"./AuthenticationResult\";\r\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\r\nimport { Authority } from \"../authority/Authority\";\r\nimport { AuthorityType } from \"../authority/AuthorityType\";\r\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\r\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\r\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\r\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { CacheManager } from \"../cache/CacheManager\";\r\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\r\nimport { AuthenticationScheme, Constants, THE_FAMILY_ID } from \"../utils/Constants\";\r\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\r\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\r\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\r\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\r\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\r\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\r\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\r\n\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nexport class ResponseHandler {\r\n    private clientId: string;\r\n    private cacheStorage: CacheManager;\r\n    private cryptoObj: ICrypto;\r\n    private logger: Logger;\r\n    private homeAccountIdentifier: string;\r\n    private serializableCache: ISerializableTokenCache | null;\r\n    private persistencePlugin: ICachePlugin | null;\r\n    private performanceClient?: IPerformanceClient;\r\n\r\n    constructor(clientId: string, cacheStorage: CacheManager, cryptoObj: ICrypto, logger: Logger, serializableCache: ISerializableTokenCache | null, persistencePlugin: ICachePlugin | null, performanceClient?: IPerformanceClient) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    validateServerAuthorizationCodeResponse(serverResponseHash: ServerAuthorizationCodeResponse, cachedState: string, cryptoObj: ICrypto): void {\r\n\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponseHash.error || Constants.EMPTY_STRING,\r\n                    serverResponseHash.error_description,\r\n                    serverResponseHash.suberror,\r\n                    serverResponseHash.timestamp || Constants.EMPTY_STRING,\r\n                    serverResponseHash.trace_id || Constants.EMPTY_STRING,\r\n                    serverResponseHash.correlation_id || Constants.EMPTY_STRING,\r\n                    serverResponseHash.claims || Constants.EMPTY_STRING,\r\n                );\r\n            }\r\n\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    validateTokenResponse(serverResponse: ServerAuthorizationTokenResponse): void {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(\r\n                    serverResponse.error,\r\n                    serverResponse.error_description,\r\n                    serverResponse.suberror,\r\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\r\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\r\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\r\n                    serverResponse.claims || Constants.EMPTY_STRING,\r\n                );\r\n            }\r\n\r\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    async handleServerTokenResponse(\r\n        serverTokenResponse: ServerAuthorizationTokenResponse,\r\n        authority: Authority,\r\n        reqTimestamp: number,\r\n        request: BaseAuthRequest,\r\n        authCodePayload?: AuthorizationCodePayload,\r\n        userAssertionHash?: string,\r\n        handlingRefreshTokenResponse?: boolean,\r\n        forceCacheRefreshTokenResponse?: boolean,\r\n        serverRequestId?: string): Promise<AuthenticationResult> {\r\n        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\r\n\r\n        // create an idToken object (not entity)\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (serverTokenResponse.id_token) {\r\n            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n\r\n            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                    throw ClientAuthError.createNonceMismatchError();\r\n                }\r\n            }\r\n\r\n            // token max_age check\r\n            if (request.maxAge || (request.maxAge === 0)) {\r\n                const authTime = idTokenObj.claims.auth_time;\r\n                if (!authTime) {\r\n                    throw ClientAuthError.createAuthTimeNotFoundError();\r\n                }\r\n\r\n                AuthToken.checkMaxAge(authTime, request.maxAge);\r\n            }\r\n        }\r\n\r\n        // generate homeAccountId\r\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n\r\n        // save the response tokens\r\n        let requestStateObj: RequestStateObject | undefined;\r\n        if (!!authCodePayload && !!authCodePayload.state) {\r\n            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n        }\r\n\r\n        // Add keyId from request to serverTokenResponse if defined\r\n        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\r\n\r\n        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistencePlugin && this.serializableCache) {\r\n                this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\r\n            }\r\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\r\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\r\n                const key = cacheRecord.account.generateAccountKey();\r\n                const account = this.cacheStorage.getAccount(key);\r\n                if (!account) {\r\n                    this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId);\r\n                }\r\n            }\r\n            await this.cacheStorage.saveCacheRecord(cacheRecord);\r\n        } finally {\r\n            if (this.persistencePlugin && this.serializableCache && cacheContext) {\r\n                this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId);\r\n    }\r\n\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    private generateCacheRecord(serverTokenResponse: ServerAuthorizationTokenResponse, authority: Authority, reqTimestamp: number, request: BaseAuthRequest, idTokenObj?: AuthToken, userAssertionHash?: string, authCodePayload?: AuthorizationCodePayload): CacheRecord {\r\n        const env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        let cachedIdToken: IdTokenEntity | undefined;\r\n        let cachedAccount: AccountEntity | undefined;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj.claims.tid || Constants.EMPTY_STRING,\r\n            );\r\n\r\n            cachedAccount = this.generateAccountEntity(\r\n                serverTokenResponse,\r\n                idTokenObj,\r\n                authority,\r\n                authCodePayload\r\n            );\r\n        }\r\n\r\n        // AccessToken\r\n        let cachedAccessToken: AccessTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n\r\n            // If scopes not returned in server response, use request scopes\r\n            const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\r\n\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            const expiresIn: number = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            const extExpiresIn: number = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            const refreshIn: number | undefined = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.access_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant,\r\n                responseScopes.printScopes(),\r\n                tokenExpirationSeconds,\r\n                extendedTokenExpirationSeconds,\r\n                this.cryptoObj,\r\n                refreshOnSeconds,\r\n                serverTokenResponse.token_type,\r\n                userAssertionHash,\r\n                serverTokenResponse.key_id,\r\n                request.claims,\r\n                request.requestedClaimsHash\r\n            );\r\n        }\r\n\r\n        // refreshToken\r\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\r\n                this.homeAccountIdentifier,\r\n                env,\r\n                serverTokenResponse.refresh_token || Constants.EMPTY_STRING,\r\n                this.clientId,\r\n                serverTokenResponse.foci,\r\n                userAssertionHash\r\n            );\r\n        }\r\n\r\n        // appMetadata\r\n        let cachedAppMetadata: AppMetadataEntity | null = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    }\r\n\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    private generateAccountEntity(serverTokenResponse: ServerAuthorizationTokenResponse, idToken: AuthToken, authority: Authority, authCodePayload?: AuthorizationCodePayload): AccountEntity {\r\n        const authorityType = authority.authorityType;\r\n        const cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\r\n        const msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\r\n\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n        }\r\n\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n    }\r\n\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    static async generateAuthenticationResult(\r\n        cryptoObj: ICrypto,\r\n        authority: Authority,\r\n        cacheRecord: CacheRecord,\r\n        fromTokenCache: boolean,\r\n        request: BaseAuthRequest,\r\n        idTokenObj?: AuthToken,\r\n        requestState?: RequestStateObject,\r\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\r\n        requestId?: string,\r\n    ): Promise<AuthenticationResult> {\r\n        let accessToken: string = Constants.EMPTY_STRING;\r\n        let responseScopes: Array<string> = [];\r\n        let expiresOn: Date | null = null;\r\n        let extExpiresOn: Date | undefined;\r\n        let familyId: string = Constants.EMPTY_STRING;\r\n\r\n        if (cacheRecord.accessToken) {\r\n            if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\r\n                const popTokenGenerator: PopTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                const { secret, keyId } = cacheRecord.accessToken;\r\n\r\n                if (!keyId) {\r\n                    throw ClientAuthError.createKeyIdMissingError();\r\n                }\r\n\r\n                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\r\n            } else {\r\n                accessToken = cacheRecord.accessToken.secret;\r\n            }\r\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n        }\r\n\r\n        if (cacheRecord.appMetadata) {\r\n            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n        }\r\n        const uid = idTokenObj?.claims.oid || idTokenObj?.claims.sub || Constants.EMPTY_STRING;\r\n        const tid = idTokenObj?.claims.tid || Constants.EMPTY_STRING;\r\n\r\n        // for hybrid + native bridge enablement, send back the native account Id\r\n        if(serverTokenResponse?.spa_accountid && !!cacheRecord.account){\r\n            cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\r\n        }\r\n\r\n        return {\r\n            authority: authority.canonicalAuthority,\r\n            uniqueId: uid,\r\n            tenantId: tid,\r\n            scopes: responseScopes,\r\n            account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n            idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n            idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n            accessToken: accessToken,\r\n            fromCache: fromTokenCache,\r\n            expiresOn: expiresOn,\r\n            correlationId: request.correlationId,\r\n            requestId: requestId || Constants.EMPTY_STRING,\r\n            extExpiresOn: extExpiresOn,\r\n            familyId: familyId,\r\n            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\r\n            state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\r\n            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\r\n            code: serverTokenResponse?.spa_code,\r\n            fromNativeBroker: false,\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}