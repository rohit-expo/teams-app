{"ast":null,"code":"import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport { useTooltipVisibility_unstable as useTooltipVisibility, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { applyTriggerPropsToChildren, resolveShorthand, useControllableState, useId, useIsomorphicLayoutEffect, useIsSSR, useMergedRefs, useTimeout, getTriggerChild, mergeCallbacks, useEventCallback } from '@fluentui/react-utilities';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */\n\nexport const useTooltip_unstable = props => {\n  var _a, _b, _c, _d;\n  const context = useTooltipVisibility();\n  const isServerSideRender = useIsSSR();\n  const {\n    targetDocument\n  } = useFluent();\n  const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n  const {\n    appearance = 'normal',\n    children,\n    content,\n    withArrow = false,\n    positioning = 'above',\n    onVisibleChange,\n    relationship,\n    showDelay = 250,\n    hideDelay = 250,\n    mountNode\n  } = props;\n  const [visible, setVisibleInternal] = useControllableState({\n    state: props.visible,\n    initialState: false\n  });\n  const setVisible = React.useCallback((newVisible, ev) => {\n    clearDelayTimeout();\n    setVisibleInternal(oldVisible => {\n      if (newVisible !== oldVisible) {\n        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, {\n          visible: newVisible\n        });\n      }\n      return newVisible;\n    });\n  }, [clearDelayTimeout, setVisibleInternal, onVisibleChange]);\n  const state = {\n    withArrow,\n    positioning,\n    showDelay,\n    hideDelay,\n    relationship,\n    visible,\n    shouldRenderTooltip: visible,\n    appearance,\n    mountNode,\n    // Slots\n    components: {\n      content: 'div'\n    },\n    content: resolveShorthand(content, {\n      defaultProps: {\n        role: 'tooltip'\n      },\n      required: true\n    })\n  };\n  state.content.id = useId('tooltip-', state.content.id);\n  const positioningOptions = {\n    enabled: state.visible,\n    arrowPadding: 2 * tooltipBorderRadius,\n    position: 'above',\n    align: 'center',\n    offset: 4,\n    ...resolvePositioningShorthand(state.positioning)\n  };\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n  }\n  const {\n    targetRef,\n    containerRef,\n    arrowRef\n  } = usePositioning(positioningOptions);\n  state.content.ref = useMergedRefs(state.content.ref, containerRef);\n  state.arrowRef = arrowRef; // When this tooltip is visible, hide any other tooltips, and register it\n  // as the visibleTooltip with the TooltipContext.\n  // Also add a listener on document to hide the tooltip if Escape is pressed\n\n  useIsomorphicLayoutEffect(() => {\n    var _a;\n    if (visible) {\n      const thisTooltip = {\n        hide: () => setVisible(false)\n      };\n      (_a = context.visibleTooltip) === null || _a === void 0 ? void 0 : _a.hide();\n      context.visibleTooltip = thisTooltip;\n      const onDocumentKeyDown = ev => {\n        if (ev.key === Escape) {\n          thisTooltip.hide(); // stop propagation to avoid conflicting with other elements that listen for `Escape`\n          // e,g: Dialog, Popover, Menu\n\n          ev.stopPropagation();\n        }\n      };\n      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener('keydown', onDocumentKeyDown, {\n        // As this event is added at targeted document,\n        // we need to capture the event to be sure keydown handling from tooltip happens first\n        capture: true\n      });\n      return () => {\n        if (context.visibleTooltip === thisTooltip) {\n          context.visibleTooltip = undefined;\n        }\n        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener('keydown', onDocumentKeyDown, {\n          capture: true\n        });\n      };\n    }\n  }, [context, targetDocument, visible, setVisible]); // The focused element gets a blur event when the document loses focus\n  // (e.g. switching tabs in the browser), but we don't want to show the\n  // tooltip again when the document gets focus back. Handle this case by\n  // checking if the blurred element is still the document's activeElement.\n  // See https://github.com/microsoft/fluentui/issues/13541\n\n  const ignoreNextFocusEventRef = React.useRef(false); // Listener for onPointerEnter and onFocus on the trigger element\n\n  const onEnterTrigger = React.useCallback(ev => {\n    if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n      ignoreNextFocusEventRef.current = false;\n      return;\n    } // Show immediately if another tooltip is already visible\n\n    const delay = context.visibleTooltip ? 0 : state.showDelay;\n    setDelayTimeout(() => {\n      setVisible(true, ev);\n    }, delay);\n    ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n  }, [setDelayTimeout, setVisible, state.showDelay, context]); // Listener for onPointerLeave and onBlur on the trigger element\n\n  const onLeaveTrigger = React.useCallback(ev => {\n    let delay = state.hideDelay;\n    if (ev.type === 'blur') {\n      // Hide immediately when losing focus\n      delay = 0;\n      ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;\n    }\n    setDelayTimeout(() => {\n      setVisible(false, ev);\n    }, delay);\n    ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n  }, [setDelayTimeout, setVisible, state.hideDelay, targetDocument]); // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n\n  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n  const child = getTriggerChild(children);\n  const triggerAriaProps = {};\n  if (relationship === 'label') {\n    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n    if (typeof state.content.children === 'string') {\n      triggerAriaProps['aria-label'] = state.content.children;\n    } else {\n      triggerAriaProps['aria-labelledby'] = state.content.id; // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n\n      state.shouldRenderTooltip = true;\n    }\n  } else if (relationship === 'description') {\n    triggerAriaProps['aria-describedby'] = state.content.id; // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n\n    state.shouldRenderTooltip = true;\n  } // Don't render the Tooltip in SSR to avoid hydration errors\n\n  if (isServerSideRender) {\n    state.shouldRenderTooltip = false;\n  }\n  const childTargetRef = useMergedRefs(child === null || child === void 0 ? void 0 : child.ref, targetRef); // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n\n  state.children = applyTriggerPropsToChildren(children, {\n    ...triggerAriaProps,\n    ...(child === null || child === void 0 ? void 0 : child.props),\n    // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n    ref: positioningOptions.target === undefined ? childTargetRef : child === null || child === void 0 ? void 0 : child.ref,\n    onPointerEnter: useEventCallback(mergeCallbacks((_a = child === null || child === void 0 ? void 0 : child.props) === null || _a === void 0 ? void 0 : _a.onPointerEnter, onEnterTrigger)),\n    onPointerLeave: useEventCallback(mergeCallbacks((_b = child === null || child === void 0 ? void 0 : child.props) === null || _b === void 0 ? void 0 : _b.onPointerLeave, onLeaveTrigger)),\n    onFocus: useEventCallback(mergeCallbacks((_c = child === null || child === void 0 ? void 0 : child.props) === null || _c === void 0 ? void 0 : _c.onFocus, onEnterTrigger)),\n    onBlur: useEventCallback(mergeCallbacks((_d = child === null || child === void 0 ? void 0 : child.props) === null || _d === void 0 ? void 0 : _d.onBlur, onLeaveTrigger))\n  });\n  return state;\n};","map":{"version":3,"mappings":"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","names":["React","mergeArrowOffset","resolvePositioningShorthand","usePositioning","useTooltipVisibility_unstable","useTooltipVisibility","useFluent_unstable","useFluent","applyTriggerPropsToChildren","resolveShorthand","useControllableState","useId","useIsomorphicLayoutEffect","useIsSSR","useMergedRefs","useTimeout","getTriggerChild","mergeCallbacks","useEventCallback","arrowHeight","tooltipBorderRadius","Escape","useTooltip_unstable","props","context","isServerSideRender","targetDocument","setDelayTimeout","clearDelayTimeout","appearance","children","content","withArrow","positioning","onVisibleChange","relationship","showDelay","hideDelay","mountNode","visible","setVisibleInternal","state","initialState","setVisible","useCallback","newVisible","ev","oldVisible","shouldRenderTooltip","components","defaultProps","role","required","id","positioningOptions","enabled","arrowPadding","position","align","offset","targetRef","containerRef","arrowRef","ref","thisTooltip","hide","visibleTooltip","_a","onDocumentKeyDown","key","stopPropagation","addEventListener","capture","undefined","removeEventListener","ignoreNextFocusEventRef","useRef","onEnterTrigger","type","current","delay","persist","onLeaveTrigger","activeElement","target","onPointerEnter","onPointerLeave","onFocus","onBlur","child","triggerAriaProps","childTargetRef","_b","_c","_d"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-tooltip\\lib\\components\\src\\packages\\react-components\\react-tooltip\\src\\components\\Tooltip\\useTooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport { mergeArrowOffset, resolvePositioningShorthand, usePositioning } from '@fluentui/react-positioning';\nimport {\n  useTooltipVisibility_unstable as useTooltipVisibility,\n  useFluent_unstable as useFluent,\n} from '@fluentui/react-shared-contexts';\nimport {\n  applyTriggerPropsToChildren,\n  resolveShorthand,\n  useControllableState,\n  useId,\n  useIsomorphicLayoutEffect,\n  useIsSSR,\n  useMergedRefs,\n  useTimeout,\n  getTriggerChild,\n  mergeCallbacks,\n  useEventCallback,\n} from '@fluentui/react-utilities';\nimport type { TooltipProps, TooltipState, TooltipChildProps } from './Tooltip.types';\nimport { arrowHeight, tooltipBorderRadius } from './private/constants';\nimport { Escape } from '@fluentui/keyboard-keys';\n\n/**\n * Create the state required to render Tooltip.\n *\n * The returned state can be modified with hooks such as useTooltipStyles_unstable,\n * before being passed to renderTooltip_unstable.\n *\n * @param props - props from this instance of Tooltip\n */\nexport const useTooltip_unstable = (props: TooltipProps): TooltipState => {\n  const context = useTooltipVisibility();\n  const isServerSideRender = useIsSSR();\n  const { targetDocument } = useFluent();\n  const [setDelayTimeout, clearDelayTimeout] = useTimeout();\n\n  const {\n    appearance = 'normal',\n    children,\n    content,\n    withArrow = false,\n    positioning = 'above',\n    onVisibleChange,\n    relationship,\n    showDelay = 250,\n    hideDelay = 250,\n    mountNode,\n  } = props;\n\n  const [visible, setVisibleInternal] = useControllableState({ state: props.visible, initialState: false });\n  const setVisible = React.useCallback(\n    (newVisible: boolean, ev?: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      clearDelayTimeout();\n      setVisibleInternal(oldVisible => {\n        if (newVisible !== oldVisible) {\n          onVisibleChange?.(ev, { visible: newVisible });\n        }\n        return newVisible;\n      });\n    },\n    [clearDelayTimeout, setVisibleInternal, onVisibleChange],\n  );\n\n  const state: TooltipState = {\n    withArrow,\n    positioning,\n    showDelay,\n    hideDelay,\n    relationship,\n    visible,\n    shouldRenderTooltip: visible,\n    appearance,\n    mountNode,\n    // Slots\n    components: {\n      content: 'div',\n    },\n    content: resolveShorthand(content, {\n      defaultProps: {\n        role: 'tooltip',\n      },\n      required: true,\n    }),\n  };\n\n  state.content.id = useId('tooltip-', state.content.id);\n\n  const positioningOptions = {\n    enabled: state.visible,\n    arrowPadding: 2 * tooltipBorderRadius,\n    position: 'above' as const,\n    align: 'center' as const,\n    offset: 4,\n    ...resolvePositioningShorthand(state.positioning),\n  };\n\n  if (state.withArrow) {\n    positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);\n  }\n\n  const {\n    targetRef,\n    containerRef,\n    arrowRef,\n  }: {\n    targetRef: React.MutableRefObject<unknown>;\n    containerRef: React.MutableRefObject<HTMLDivElement>;\n    arrowRef: React.MutableRefObject<HTMLDivElement>;\n  } = usePositioning(positioningOptions);\n\n  state.content.ref = useMergedRefs(state.content.ref, containerRef);\n  state.arrowRef = arrowRef;\n\n  // When this tooltip is visible, hide any other tooltips, and register it\n  // as the visibleTooltip with the TooltipContext.\n  // Also add a listener on document to hide the tooltip if Escape is pressed\n  useIsomorphicLayoutEffect(() => {\n    if (visible) {\n      const thisTooltip = { hide: () => setVisible(false) };\n\n      context.visibleTooltip?.hide();\n      context.visibleTooltip = thisTooltip;\n\n      const onDocumentKeyDown = (ev: KeyboardEvent) => {\n        if (ev.key === Escape) {\n          thisTooltip.hide();\n          // stop propagation to avoid conflicting with other elements that listen for `Escape`\n          // e,g: Dialog, Popover, Menu\n          ev.stopPropagation();\n        }\n      };\n\n      targetDocument?.addEventListener('keydown', onDocumentKeyDown, {\n        // As this event is added at targeted document,\n        // we need to capture the event to be sure keydown handling from tooltip happens first\n        capture: true,\n      });\n\n      return () => {\n        if (context.visibleTooltip === thisTooltip) {\n          context.visibleTooltip = undefined;\n        }\n\n        targetDocument?.removeEventListener('keydown', onDocumentKeyDown, { capture: true });\n      };\n    }\n  }, [context, targetDocument, visible, setVisible]);\n\n  // The focused element gets a blur event when the document loses focus\n  // (e.g. switching tabs in the browser), but we don't want to show the\n  // tooltip again when the document gets focus back. Handle this case by\n  // checking if the blurred element is still the document's activeElement.\n  // See https://github.com/microsoft/fluentui/issues/13541\n  const ignoreNextFocusEventRef = React.useRef(false);\n\n  // Listener for onPointerEnter and onFocus on the trigger element\n  const onEnterTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      if (ev.type === 'focus' && ignoreNextFocusEventRef.current) {\n        ignoreNextFocusEventRef.current = false;\n        return;\n      }\n\n      // Show immediately if another tooltip is already visible\n      const delay = context.visibleTooltip ? 0 : state.showDelay;\n\n      setDelayTimeout(() => {\n        setVisible(true, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.showDelay, context],\n  );\n\n  // Listener for onPointerLeave and onBlur on the trigger element\n  const onLeaveTrigger = React.useCallback(\n    (ev: React.PointerEvent<HTMLElement> | React.FocusEvent<HTMLElement>) => {\n      let delay = state.hideDelay;\n\n      if (ev.type === 'blur') {\n        // Hide immediately when losing focus\n        delay = 0;\n\n        ignoreNextFocusEventRef.current = targetDocument?.activeElement === ev.target;\n      }\n\n      setDelayTimeout(() => {\n        setVisible(false, ev);\n      }, delay);\n\n      ev.persist(); // Persist the event since the setVisible call will happen asynchronously\n    },\n    [setDelayTimeout, setVisible, state.hideDelay, targetDocument],\n  );\n\n  // Cancel the hide timer when the mouse or focus enters the tooltip, and restart it when the mouse or focus leaves.\n  // This keeps the tooltip visible when the mouse is moved over it, or it has focus within.\n  state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);\n  state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);\n  state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);\n  state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);\n\n  const child = getTriggerChild(children);\n\n  const triggerAriaProps: Pick<TooltipChildProps, 'aria-label' | 'aria-labelledby' | 'aria-describedby'> = {};\n\n  if (relationship === 'label') {\n    // aria-label only works if the content is a string. Otherwise, need to use aria-labelledby.\n    if (typeof state.content.children === 'string') {\n      triggerAriaProps['aria-label'] = state.content.children;\n    } else {\n      triggerAriaProps['aria-labelledby'] = state.content.id;\n      // Always render the tooltip even if hidden, so that aria-labelledby refers to a valid element\n      state.shouldRenderTooltip = true;\n    }\n  } else if (relationship === 'description') {\n    triggerAriaProps['aria-describedby'] = state.content.id;\n    // Always render the tooltip even if hidden, so that aria-describedby refers to a valid element\n    state.shouldRenderTooltip = true;\n  }\n\n  // Don't render the Tooltip in SSR to avoid hydration errors\n  if (isServerSideRender) {\n    state.shouldRenderTooltip = false;\n  }\n\n  const childTargetRef = useMergedRefs(child?.ref, targetRef);\n\n  // Apply the trigger props to the child, either by calling the render function, or cloning with the new props\n  state.children = applyTriggerPropsToChildren(children, {\n    ...triggerAriaProps,\n    ...child?.props,\n    // If the target prop is not provided, attach targetRef to the trigger element's ref prop\n    ref: positioningOptions.target === undefined ? childTargetRef : child?.ref,\n    onPointerEnter: useEventCallback(mergeCallbacks(child?.props?.onPointerEnter, onEnterTrigger)),\n    onPointerLeave: useEventCallback(mergeCallbacks(child?.props?.onPointerLeave, onLeaveTrigger)),\n    onFocus: useEventCallback(mergeCallbacks(child?.props?.onFocus, onEnterTrigger)),\n    onBlur: useEventCallback(mergeCallbacks(child?.props?.onBlur, onLeaveTrigger)),\n  });\n\n  return state;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}