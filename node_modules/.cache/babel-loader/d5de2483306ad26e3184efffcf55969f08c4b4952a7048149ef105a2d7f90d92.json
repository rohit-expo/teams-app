{"ast":null,"code":"import * as React from 'react';\nimport { useThemeClassName_unstable as useThemeClassName, useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { __styles, mergeClasses } from '@griffel/react';\nimport { useFocusVisible } from '@fluentui/react-tabster';\nconst useStyles = /*#__PURE__*/__styles({\n  \"root\": {\n    \"qhf8xq\": \"f10pi13n\",\n    \"Bj3rh1h\": \"f494woh\"\n  }\n}, {\n  \"d\": [\".f10pi13n{position:relative;}\", \".f494woh{z-index:1000000;}\"]\n});\n/**\n * Creates a new element on a document.body to mount portals\n */\n\nexport const usePortalMountNode = options => {\n  const {\n    targetDocument,\n    dir\n  } = useFluent();\n  const focusVisibleRef = useFocusVisible();\n  const classes = useStyles();\n  const themeClassName = useThemeClassName();\n  const className = mergeClasses(themeClassName, classes.root);\n  const element = React.useMemo(() => {\n    if (targetDocument === undefined || options.disabled) {\n      return null;\n    }\n    const newElement = targetDocument.createElement('div');\n    targetDocument.body.appendChild(newElement);\n    return newElement;\n  }, [targetDocument, options.disabled]); // This useMemo call is intentional\n  // We don't want to re-create the portal element when its attributes change.\n  // This also should not be done in an effect because, changing the value of css variables\n  // after initial mount can trigger interesting CSS side effects like transitions.\n\n  React.useMemo(() => {\n    if (element) {\n      const classesToApply = className.split(' ').filter(Boolean);\n      element.classList.add(...classesToApply);\n      element.setAttribute('dir', dir);\n      focusVisibleRef.current = element;\n      return () => {\n        element.classList.remove(...classesToApply);\n        element.removeAttribute('dir');\n      };\n    }\n  }, [className, dir, element, focusVisibleRef]);\n  React.useEffect(() => {\n    return () => {\n      var _a;\n      (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(element);\n    };\n  }, [element]);\n  return element;\n};","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SACEC,0BAA0B,IAAIC,iBADhC,EAEEC,kBAAkB,IAAIC,SAFxB,QAGO,iCAHP;AAIA,mBAAqBC,YAArB,QAAyC,gBAAzC;AACA,SAASC,eAAT,QAAgC,yBAAhC;AASA,MAAMC,SAAS,gBAAGC;EAAA;IAAA;IAAA;EAAA;AAAA;EAAA;AAAA,EAAlB;AAOA;;AAEG;;AACH,OAAO,MAAMC,kBAAkB,GAAIC,OAAD,IAA2D;EAC3F,MAAM;IAAEC,cAAF;IAAkBC;EAAlB,IAA0BR,SAAS,EAAzC;EACA,MAAMS,eAAe,GAAGP,eAAe,EAAvC;EAEA,MAAMQ,OAAO,GAAGP,SAAS,EAAzB;EACA,MAAMQ,cAAc,GAAGb,iBAAiB,EAAxC;EAEA,MAAMc,SAAS,GAAGX,YAAY,CAACU,cAAD,EAAiBD,OAAO,CAACG,IAAzB,CAA9B;EAEA,MAAMC,OAAO,GAAGlB,KAAK,CAACmB,OAAN,CAAc,MAAK;IACjC,IAAIR,cAAc,KAAKS,SAAnB,IAAgCV,OAAO,CAACW,QAA5C,EAAsD;MACpD,OAAO,IAAP;IACD;IAED,MAAMC,UAAU,GAAGX,cAAc,CAACY,aAAf,CAA6B,KAA7B,CAAnB;IACAZ,cAAc,CAACa,IAAf,CAAoBC,WAApB,CAAgCH,UAAhC;IAEA,OAAOA,UAAP;EACD,CATe,EASb,CAACX,cAAD,EAAiBD,OAAO,CAACW,QAAzB,CATa,CAAhB,CAT2F,CAoB3F;EACA;EACA;EACA;;EACArB,KAAK,CAACmB,OAAN,CAAc,MAAK;IACjB,IAAID,OAAJ,EAAa;MACX,MAAMQ,cAAc,GAAGV,SAAS,CAACW,KAAV,CAAgB,GAAhB,EAAqBC,MAArB,CAA4BC,OAA5B,CAAvB;MAEAX,OAAO,CAACY,SAAR,CAAkBC,GAAlB,CAAsB,GAAGL,cAAzB;MACAR,OAAO,CAACc,YAAR,CAAqB,KAArB,EAA4BpB,GAA5B;MACAC,eAAe,CAACoB,OAAhB,GAA0Bf,OAA1B;MAEA,OAAO,MAAK;QACVA,OAAO,CAACY,SAAR,CAAkBI,MAAlB,CAAyB,GAAGR,cAA5B;QACAR,OAAO,CAACiB,eAAR,CAAwB,KAAxB;MACD,CAHD;IAID;EACF,CAbD,EAaG,CAACnB,SAAD,EAAYJ,GAAZ,EAAiBM,OAAjB,EAA0BL,eAA1B,CAbH;EAeAb,KAAK,CAACoC,SAAN,CAAgB,MAAK;IACnB,OAAO,MAAK;;MACV,aAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,aAAT,MAAsB,IAAtB,IAAsBC,aAAtB,GAAsB,MAAtB,GAAsBA,GAAEC,WAAF,CAAcrB,OAAd,CAAtB;IACD,CAFD;EAGD,CAJD,EAIG,CAACA,OAAD,CAJH;EAMA,OAAOA,OAAP;AACD,CA9CM","names":["React","useThemeClassName_unstable","useThemeClassName","useFluent_unstable","useFluent","mergeClasses","useFocusVisible","useStyles","__styles","usePortalMountNode","options","targetDocument","dir","focusVisibleRef","classes","themeClassName","className","root","element","useMemo","undefined","disabled","newElement","createElement","body","appendChild","classesToApply","split","filter","Boolean","classList","add","setAttribute","current","remove","removeAttribute","useEffect","parentElement","_a","removeChild"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-portal\\lib\\components\\src\\packages\\react-components\\react-portal\\src\\components\\Portal\\usePortalMountNode.ts"],"sourcesContent":["import * as React from 'react';\nimport {\n  useThemeClassName_unstable as useThemeClassName,\n  useFluent_unstable as useFluent,\n} from '@fluentui/react-shared-contexts';\nimport { makeStyles, mergeClasses } from '@griffel/react';\nimport { useFocusVisible } from '@fluentui/react-tabster';\n\nexport type UsePortalMountNodeOptions = {\n  /**\n   * Since hooks cannot be called conditionally use this flag to disable creating the node\n   */\n  disabled?: boolean;\n};\n\nconst useStyles = makeStyles({\n  root: {\n    position: 'relative',\n    zIndex: 1000000,\n  },\n});\n\n/**\n * Creates a new element on a document.body to mount portals\n */\nexport const usePortalMountNode = (options: UsePortalMountNodeOptions): HTMLElement | null => {\n  const { targetDocument, dir } = useFluent();\n  const focusVisibleRef = useFocusVisible<HTMLDivElement>() as React.MutableRefObject<HTMLElement | null>;\n\n  const classes = useStyles();\n  const themeClassName = useThemeClassName();\n\n  const className = mergeClasses(themeClassName, classes.root);\n\n  const element = React.useMemo(() => {\n    if (targetDocument === undefined || options.disabled) {\n      return null;\n    }\n\n    const newElement = targetDocument.createElement('div');\n    targetDocument.body.appendChild(newElement);\n\n    return newElement;\n  }, [targetDocument, options.disabled]);\n\n  // This useMemo call is intentional\n  // We don't want to re-create the portal element when its attributes change.\n  // This also should not be done in an effect because, changing the value of css variables\n  // after initial mount can trigger interesting CSS side effects like transitions.\n  React.useMemo(() => {\n    if (element) {\n      const classesToApply = className.split(' ').filter(Boolean);\n\n      element.classList.add(...classesToApply);\n      element.setAttribute('dir', dir);\n      focusVisibleRef.current = element;\n\n      return () => {\n        element.classList.remove(...classesToApply);\n        element.removeAttribute('dir');\n      };\n    }\n  }, [className, dir, element, focusVisibleRef]);\n\n  React.useEffect(() => {\n    return () => {\n      element?.parentElement?.removeChild(element);\n    };\n  }, [element]);\n\n  return element;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}