{"ast":null,"code":"import * as React from 'react';\nfunction isFactoryDispatch(newState) {\n  return typeof newState === 'function';\n}\n/**\n * @internal\n *\n * A `useState`-like hook to manage a value that could be either controlled or uncontrolled,\n * such as a checked state or text input string.\n *\n * Unlike `setState`, it's okay to call the returned updater (dispatch) function for either a\n * controlled or uncontrolled component. Calls will only be respected if the component is uncontrolled.\n *\n * @returns Same as [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate): an array\n * of the current value and an updater (dispatch) function. The updater function is referentially\n * stable (won't change during the component's lifecycle). It can take either a new value, or a\n * function which is passed the previous value and returns the new value. Unlike `setState`, calls\n * to the updater function will only be respected if the component is uncontrolled.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\n\nexport const useControllableState = options => {\n  const isControlled = useIsControlled(options.state);\n  const initialState = typeof options.defaultState === 'undefined' ? options.initialState : options.defaultState;\n  const [internalState, setInternalState] = React.useState(initialState);\n  const state = isControlled ? options.state : internalState;\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]); // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n\n  const setState = React.useCallback(newState => {\n    // React dispatch can use a factory\n    // https://reactjs.org/docs/hooks-reference.html#functional-updates\n    if (isFactoryDispatch(newState)) {\n      stateRef.current = newState(stateRef.current);\n    } else {\n      stateRef.current = newState;\n    }\n    setInternalState(stateRef.current);\n  }, []);\n  return [state, setState];\n};\n/**\n * Helper hook to handle previous comparison of controlled/uncontrolled\n * Prints an error when isControlled value switches between subsequent renders\n * @returns - whether the value is controlled\n */\n\nconst useIsControlled = controlledValue => {\n  const [isControlled] = React.useState(() => controlledValue !== undefined);\n  if (process.env.NODE_ENV !== 'production') {\n    // We don't want these warnings in production even though it is against native behaviour\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      if (isControlled !== (controlledValue !== undefined)) {\n        const error = new Error();\n        const controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';\n        const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined'; // eslint-disable-next-line no-console\n\n        console.error([\n        // Default react error\n        'A component is changing ' + controlWarning + '. This is likely caused by the value', 'changing from ' + undefinedWarning + ' value, which should not happen.', 'Decide between using a controlled or uncontrolled input element for the lifetime of the component.', 'More info: https://reactjs.org/link/controlled-components', error.stack].join(' '));\n      }\n    }, [isControlled, controlledValue]);\n  }\n  return isControlled;\n};","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAqBA,SAASC,iBAAT,CAAkCC,QAAlC,EAAuE;EACrE,OAAO,OAAOA,QAAP,KAAoB,UAA3B;AACD;AAED;;;;;;;;;;;;;;;AAeG;;AACH,OAAO,MAAMC,oBAAoB,GAC/BC,OADkC,IAEsB;EACxD,MAAMC,YAAY,GAAGC,eAAe,CAACF,OAAO,CAACG,KAAT,CAApC;EACA,MAAMC,YAAY,GAAG,OAAOJ,OAAO,CAACK,YAAf,KAAgC,WAAhC,GAA8CL,OAAO,CAACI,YAAtD,GAAqEJ,OAAO,CAACK,YAAlG;EACA,MAAM,CAACC,aAAD,EAAgBC,gBAAhB,IAAoCX,KAAK,CAACY,QAAN,CAAsBJ,YAAtB,CAA1C;EAEA,MAAMD,KAAK,GAAGF,YAAY,GAAID,OAAO,CAACG,KAAZ,GAA8BG,aAAxD;EAEA,MAAMG,QAAQ,GAAGb,KAAK,CAACc,MAAN,CAAaP,KAAb,CAAjB;EACAP,KAAK,CAACe,SAAN,CAAgB,MAAK;IACnBF,QAAQ,CAACG,OAAT,GAAmBT,KAAnB;EACD,CAFD,EAEG,CAACA,KAAD,CAFH,EARwD,CAYxD;EACA;;EACA,MAAMU,QAAQ,GAAGjB,KAAK,CAACkB,WAAN,CAAmBhB,QAAD,IAA0C;IAC3E;IACA;IACA,IAAID,iBAAiB,CAACC,QAAD,CAArB,EAAiC;MAC/BW,QAAQ,CAACG,OAAT,GAAmBd,QAAQ,CAACW,QAAQ,CAACG,OAAV,CAA3B;IACD,CAFD,MAEO;MACLH,QAAQ,CAACG,OAAT,GAAmBd,QAAnB;IACD;IAEDS,gBAAgB,CAACE,QAAQ,CAACG,OAAV,CAAhB;EACD,CAVgB,EAUd,EAVc,CAAjB;EAYA,OAAO,CAACT,KAAD,EAAQU,QAAR,CAAP;AACD,CA7BM;AA+BP;;;;AAIG;;AACH,MAAMX,eAAe,GAAIa,eAAD,IAA6B;EACnD,MAAM,CAACd,YAAD,IAAiBL,KAAK,CAACY,QAAN,CAAwB,MAAMO,eAAe,KAAKC,SAAlD,CAAvB;EAEA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC;IACA;IACAvB,KAAK,CAACe,SAAN,CAAgB,MAAK;MACnB,IAAIV,YAAY,MAAMc,eAAe,KAAKC,SAA1B,CAAhB,EAAsD;QACpD,MAAMI,KAAK,GAAG,IAAIC,KAAJ,EAAd;QAEA,MAAMC,cAAc,GAAGrB,YAAY,GAC/B,uCAD+B,GAE/B,wCAFJ;QAIA,MAAMsB,gBAAgB,GAAGtB,YAAY,GAAG,yBAAH,GAA+B,wBAApE,CAPoD,CASpD;;QACAuB,OAAO,CAACJ,KAAR,CACE;QACE;QACA,6BAA6BE,cAA7B,GAA8C,sCAFhD,EAGE,mBAAmBC,gBAAnB,GAAsC,kCAHxC,EAIE,oGAJF,EAKE,2DALF,EAMEH,KAAK,CAACK,KANR,EAOEC,IAPF,CAOO,GAPP,CADF;MAUD;IACF,CAtBD,EAsBG,CAACzB,YAAD,EAAec,eAAf,CAtBH;EAuBD;EAED,OAAOd,YAAP;AACD,CAhCD","names":["React","isFactoryDispatch","newState","useControllableState","options","isControlled","useIsControlled","state","initialState","defaultState","internalState","setInternalState","useState","stateRef","useRef","useEffect","current","setState","useCallback","controlledValue","undefined","process","env","NODE_ENV","error","Error","controlWarning","undefinedWarning","console","stack","join"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-utilities\\lib\\src\\packages\\react-components\\react-utilities\\src\\hooks\\useControllableState.ts"],"sourcesContent":["import * as React from 'react';\n\n/**\n * @internal\n */\nexport type UseControllableStateOptions<State> = {\n  /**\n   * User-provided default state or initializer, for uncontrolled usage.\n   */\n  defaultState?: State | (() => State);\n  /**\n   * User-provided controlled state. `undefined` means internal state will be used.\n   */\n  state: State | undefined;\n  /**\n   * Used as the initial state if `state` and `defaultState` are both `undefined`.\n   * If `undefined` is the correct initial state, pass that here.\n   */\n  initialState: State;\n};\n\nfunction isFactoryDispatch<State>(newState: React.SetStateAction<State>): newState is (prevState: State) => State {\n  return typeof newState === 'function';\n}\n\n/**\n * @internal\n *\n * A `useState`-like hook to manage a value that could be either controlled or uncontrolled,\n * such as a checked state or text input string.\n *\n * Unlike `setState`, it's okay to call the returned updater (dispatch) function for either a\n * controlled or uncontrolled component. Calls will only be respected if the component is uncontrolled.\n *\n * @returns Same as [`useState`](https://reactjs.org/docs/hooks-reference.html#usestate): an array\n * of the current value and an updater (dispatch) function. The updater function is referentially\n * stable (won't change during the component's lifecycle). It can take either a new value, or a\n * function which is passed the previous value and returns the new value. Unlike `setState`, calls\n * to the updater function will only be respected if the component is uncontrolled.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport const useControllableState = <State>(\n  options: UseControllableStateOptions<State>,\n): [State, React.Dispatch<React.SetStateAction<State>>] => {\n  const isControlled = useIsControlled(options.state);\n  const initialState = typeof options.defaultState === 'undefined' ? options.initialState : options.defaultState;\n  const [internalState, setInternalState] = React.useState<State>(initialState);\n\n  const state = isControlled ? (options.state as State) : internalState;\n\n  const stateRef = React.useRef(state);\n  React.useEffect(() => {\n    stateRef.current = state;\n  }, [state]);\n\n  // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n  const setState = React.useCallback((newState: React.SetStateAction<State>) => {\n    // React dispatch can use a factory\n    // https://reactjs.org/docs/hooks-reference.html#functional-updates\n    if (isFactoryDispatch(newState)) {\n      stateRef.current = newState(stateRef.current);\n    } else {\n      stateRef.current = newState;\n    }\n\n    setInternalState(stateRef.current);\n  }, []);\n\n  return [state, setState];\n};\n\n/**\n * Helper hook to handle previous comparison of controlled/uncontrolled\n * Prints an error when isControlled value switches between subsequent renders\n * @returns - whether the value is controlled\n */\nconst useIsControlled = (controlledValue: unknown) => {\n  const [isControlled] = React.useState<boolean>(() => controlledValue !== undefined);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // We don't want these warnings in production even though it is against native behaviour\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useEffect(() => {\n      if (isControlled !== (controlledValue !== undefined)) {\n        const error = new Error();\n\n        const controlWarning = isControlled\n          ? 'a controlled value to be uncontrolled'\n          : 'an uncontrolled value to be controlled';\n\n        const undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined';\n\n        // eslint-disable-next-line no-console\n        console.error(\n          [\n            // Default react error\n            'A component is changing ' + controlWarning + '. This is likely caused by the value',\n            'changing from ' + undefinedWarning + ' value, which should not happen.',\n            'Decide between using a controlled or uncontrolled input element for the lifetime of the component.',\n            'More info: https://reactjs.org/link/controlled-components',\n            error.stack,\n          ].join(' '),\n        );\n      }\n    }, [isControlled, controlledValue]);\n  }\n\n  return isControlled;\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}