{"ast":null,"code":"import * as React from 'react';\nimport { useEventCallback } from './useEventCallback';\n/**\n * @internal\n * Utility to perform checks where a click/touch event was made outside a component\n */\n\nexport const useOnClickOutside = options => {\n  const {\n    refs,\n    callback,\n    element,\n    disabled,\n    contains: containsProp\n  } = options;\n  const timeoutId = React.useRef(undefined);\n  useIFrameFocus(!disabled, element, callback);\n  const listener = useEventCallback(ev => {\n    const contains = containsProp || ((parent, child) => !!(parent === null || parent === void 0 ? void 0 : parent.contains(child)));\n    const isOutside = refs.every(ref => !contains(ref.current || null, ev.target));\n    if (isOutside && !disabled) {\n      callback(ev);\n    }\n  });\n  React.useEffect(() => {\n    // Store the current event to avoid triggering handlers immediately\n    // Note this depends on a deprecated but extremely well supported quirk of the web platform\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = getWindowEvent(window);\n    const conditionalHandler = event => {\n      // Skip if this event is the same as the one running when we added the handlers\n      if (event === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n      listener(event);\n    };\n    if (!disabled) {\n      // use capture phase because React can update DOM before the event bubbles to the document\n      element === null || element === void 0 ? void 0 : element.addEventListener('click', conditionalHandler, true);\n      element === null || element === void 0 ? void 0 : element.addEventListener('touchstart', conditionalHandler, true);\n      element === null || element === void 0 ? void 0 : element.addEventListener('contextmenu', conditionalHandler, true);\n    } // Garbage collect this event after it's no longer useful to avoid memory leaks\n\n    timeoutId.current = window.setTimeout(() => {\n      currentEvent = undefined;\n    }, 1);\n    return () => {\n      element === null || element === void 0 ? void 0 : element.removeEventListener('click', conditionalHandler, true);\n      element === null || element === void 0 ? void 0 : element.removeEventListener('touchstart', conditionalHandler, true);\n      element === null || element === void 0 ? void 0 : element.removeEventListener('contextmenu', conditionalHandler, true);\n      clearTimeout(timeoutId.current);\n      currentEvent = undefined;\n    };\n  }, [listener, element, disabled]);\n};\nconst getWindowEvent = target => {\n  var _a, _b, _c;\n  if (target) {\n    if (typeof target.window === 'object' && target.window === target) {\n      // eslint-disable-next-line deprecation/deprecation\n      return target.event;\n    } // eslint-disable-next-line deprecation/deprecation\n\n    return (_c = (_b = (_a = target.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.event) !== null && _c !== void 0 ? _c : undefined;\n  }\n  return undefined;\n};\nconst FUI_FRAME_EVENT = 'fuiframefocus';\n/**\n * Since click events do not propagate past iframes, we use focus to detect if a\n * click has happened inside an iframe, since the only ways of focusing inside an\n * iframe are:\n *   - clicking inside\n *   - tabbing inside\n *\n * Polls the value of `document.activeElement`. If it is an iframe, then dispatch\n * a custom DOM event. When the custom event is received call the provided callback\n *\n * @param enableFrameFocusDispatch - boolean flag to start dispatching events\n * @param targetDocument - the document to dispatch events and set timeouts\n * @param pollDuration  - in milliseconds\n */\n\nconst useIFrameFocus = function (enableFrameFocusDispatch, targetDocument, callback) {\n  let pollDuration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n  const timeoutRef = React.useRef();\n  const listener = useEventCallback(e => {\n    if (callback) {\n      callback(e);\n    }\n  }); // Adds listener to the custom iframe focus event\n\n  React.useEffect(() => {\n    if (enableFrameFocusDispatch) {\n      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);\n    }\n    return () => {\n      targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, listener]); // Starts polling for the active element\n\n  React.useEffect(() => {\n    var _a;\n    if (enableFrameFocusDispatch) {\n      timeoutRef.current = (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.setInterval(() => {\n        const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;\n        if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'IFRAME' || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === 'WEBVIEW') {\n          const event = new CustomEvent(FUI_FRAME_EVENT, {\n            bubbles: true\n          });\n          activeElement.dispatchEvent(event);\n        }\n      }, pollDuration);\n    }\n    return () => {\n      var _a;\n      (_a = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) === null || _a === void 0 ? void 0 : _a.clearTimeout(timeoutRef.current);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, pollDuration]);\n};","map":{"version":3,"mappings":"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","names":["React","useEventCallback","useOnClickOutside","options","refs","callback","element","disabled","contains","containsProp","timeoutId","useRef","undefined","useIFrameFocus","listener","ev","parent","child","isOutside","every","ref","current","target","useEffect","currentEvent","getWindowEvent","window","conditionalHandler","event","addEventListener","setTimeout","removeEventListener","clearTimeout","ownerDocument","_a","defaultView","_b","_c","FUI_FRAME_EVENT","enableFrameFocusDispatch","targetDocument","pollDuration","timeoutRef","e","setInterval","activeElement","tagName","CustomEvent","bubbles","dispatchEvent"],"sources":["D:\\teams-app\\qlik2\\Microsoft-Teams-Samples\\samples\\tab-personal-sso-quickstart\\js\\node_modules\\@fluentui\\react-utilities\\lib\\src\\packages\\react-components\\react-utilities\\src\\hooks\\useOnClickOutside.ts"],"sourcesContent":["import * as React from 'react';\nimport { useEventCallback } from './useEventCallback';\n\n/**\n * @internal\n */\nexport type UseOnClickOrScrollOutsideOptions = {\n  /**\n   * The element to listen for the click event\n   */\n  element: Document | undefined;\n  /**\n   * Refs to elements that check if the click is outside\n   */\n  refs: React.MutableRefObject<HTMLElement | undefined | null>[];\n\n  /**\n   * By default uses element.contains, but custom contain function can be provided\n   * @param parentRef - provided parent ref\n   * @param child - event target element\n   */\n  contains?(parent: HTMLElement | null, child: HTMLElement): boolean;\n\n  /**\n   * Disables event listeners\n   */\n  disabled?: boolean;\n\n  /**\n   * Called if the click is outside the element refs\n   */\n  callback: (ev: MouseEvent | TouchEvent) => void;\n};\n\n/**\n * @internal\n * Utility to perform checks where a click/touch event was made outside a component\n */\nexport const useOnClickOutside = (options: UseOnClickOrScrollOutsideOptions) => {\n  const { refs, callback, element, disabled, contains: containsProp } = options;\n  const timeoutId = React.useRef<number | undefined>(undefined);\n  useIFrameFocus(!disabled, element, callback as (e: Event) => void);\n\n  const listener = useEventCallback((ev: MouseEvent | TouchEvent) => {\n    const contains: UseOnClickOrScrollOutsideOptions['contains'] =\n      containsProp || ((parent, child) => !!parent?.contains(child));\n\n    const isOutside = refs.every(ref => !contains(ref.current || null, ev.target as HTMLElement));\n    if (isOutside && !disabled) {\n      callback(ev);\n    }\n  });\n\n  React.useEffect(() => {\n    // Store the current event to avoid triggering handlers immediately\n    // Note this depends on a deprecated but extremely well supported quirk of the web platform\n    // https://github.com/facebook/react/issues/20074\n    let currentEvent = getWindowEvent(window);\n\n    const conditionalHandler = (event: MouseEvent | TouchEvent) => {\n      // Skip if this event is the same as the one running when we added the handlers\n      if (event === currentEvent) {\n        currentEvent = undefined;\n        return;\n      }\n\n      listener(event);\n    };\n\n    if (!disabled) {\n      // use capture phase because React can update DOM before the event bubbles to the document\n      element?.addEventListener('click', conditionalHandler, true);\n      element?.addEventListener('touchstart', conditionalHandler, true);\n      element?.addEventListener('contextmenu', conditionalHandler, true);\n    }\n\n    // Garbage collect this event after it's no longer useful to avoid memory leaks\n    timeoutId.current = window.setTimeout(() => {\n      currentEvent = undefined;\n    }, 1);\n\n    return () => {\n      element?.removeEventListener('click', conditionalHandler, true);\n      element?.removeEventListener('touchstart', conditionalHandler, true);\n      element?.removeEventListener('contextmenu', conditionalHandler, true);\n\n      clearTimeout(timeoutId.current);\n      currentEvent = undefined;\n    };\n  }, [listener, element, disabled]);\n};\n\nconst getWindowEvent = (target: Node | Window): Event | undefined => {\n  if (target) {\n    if (typeof (target as Window).window === 'object' && (target as Window).window === target) {\n      // eslint-disable-next-line deprecation/deprecation\n      return target.event;\n    }\n\n    // eslint-disable-next-line deprecation/deprecation\n    return (target as Node).ownerDocument?.defaultView?.event ?? undefined;\n  }\n\n  return undefined;\n};\n\nconst FUI_FRAME_EVENT = 'fuiframefocus';\n\n/**\n * Since click events do not propagate past iframes, we use focus to detect if a\n * click has happened inside an iframe, since the only ways of focusing inside an\n * iframe are:\n *   - clicking inside\n *   - tabbing inside\n *\n * Polls the value of `document.activeElement`. If it is an iframe, then dispatch\n * a custom DOM event. When the custom event is received call the provided callback\n *\n * @param enableFrameFocusDispatch - boolean flag to start dispatching events\n * @param targetDocument - the document to dispatch events and set timeouts\n * @param pollDuration  - in milliseconds\n */\nconst useIFrameFocus = (\n  enableFrameFocusDispatch: boolean,\n  targetDocument: Document | undefined,\n  callback: (e: Event) => void,\n  pollDuration: number = 1000,\n) => {\n  const timeoutRef = React.useRef<number>();\n\n  const listener = useEventCallback((e: Event) => {\n    if (callback) {\n      callback(e);\n    }\n  });\n\n  // Adds listener to the custom iframe focus event\n  React.useEffect(() => {\n    if (enableFrameFocusDispatch) {\n      targetDocument?.addEventListener(FUI_FRAME_EVENT, listener, true);\n    }\n    return () => {\n      targetDocument?.removeEventListener(FUI_FRAME_EVENT, listener, true);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, listener]);\n\n  // Starts polling for the active element\n  React.useEffect(() => {\n    if (enableFrameFocusDispatch) {\n      timeoutRef.current = targetDocument?.defaultView?.setInterval(() => {\n        const activeElement = targetDocument?.activeElement;\n        if (activeElement?.tagName === 'IFRAME' || activeElement?.tagName === 'WEBVIEW') {\n          const event = new CustomEvent(FUI_FRAME_EVENT, { bubbles: true });\n          activeElement.dispatchEvent(event);\n        }\n      }, pollDuration);\n    }\n    return () => {\n      targetDocument?.defaultView?.clearTimeout(timeoutRef.current);\n    };\n  }, [targetDocument, enableFrameFocusDispatch, pollDuration]);\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}